{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Disjoint Interval Set (DIS)","text":"<p> A Boolean Algebra for C++   Modern, elegant, and mathematically rigorous interval set library </p>"},{"location":"#overview","title":"Overview","text":"<p>Disjoint Interval Set (DIS) is a modern C++ header-only library implementing interval sets as a complete Boolean algebra. Unlike traditional interval libraries that focus on container semantics, DIS treats interval sets as first-class mathematical objects with intuitive operations and strong correctness guarantees.</p> <pre><code>#include &lt;dis/dis.hpp&gt;\nusing namespace dis;\n\n// Create intervals with expressive factory methods\nauto morning = real_interval::closed(9, 12);    // [9, 12]\nauto afternoon = real_interval::closed(14, 18); // [14, 18]\n\n// Build sets using fluent interface\nauto work_hours = real_set{}.add(morning).add(afternoon);\n\n// Parse from mathematical notation\nauto meetings = real_set::from_string(\"[10,11] \u222a [15,16]\");\n\n// Boolean operations with natural syntax\nauto free_time = work_hours - meetings;         // Set difference\n</code></pre>"},{"location":"#why-dis","title":"Why DIS?","text":"<p>Working with intervals is fundamental in many domains\u2014from computational geometry to scheduling algorithms. DIS provides:</p>"},{"location":"#mathematical-elegance","title":"Mathematical Elegance","text":"<p>Operations follow Boolean algebra axioms rigorously, providing strong correctness guarantees and intuitive semantics.</p>"},{"location":"#intuitive-api","title":"Intuitive API","text":"<p>Express complex set operations naturally with multiple equivalent notations:</p> <ul> <li>Operators: <code>(a | b) &amp; ~c</code> for concise symbolic notation</li> <li>Methods: <code>a.unite(b).intersect(c.complement())</code> for clarity</li> <li>Fluent: <code>real_set{}.add(0,10).add(20,30)</code> for chaining</li> </ul>"},{"location":"#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<p>Compile-time interval validation with no runtime overhead. Everything is <code>constexpr</code> where possible.</p>"},{"location":"#composability","title":"Composability","text":"<p>Features combine seamlessly without surprises. All operations maintain the disjoint invariant automatically.</p>"},{"location":"#production-ready","title":"Production Ready","text":"<p>97.46% test coverage on core implementation, extensively tested with 94 test cases across edge cases and real-world scenarios.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#complete-boolean-algebra","title":"\ud83c\udfaf Complete Boolean Algebra","text":"<p>Full support for union, intersection, complement, difference, and symmetric difference with proper algebraic properties.</p>"},{"location":"#elegant-fluent-api","title":"\ud83d\udcd0 Elegant, Fluent API","text":"<p>Express complex interval operations naturally with an API that reads like mathematical notation.</p>"},{"location":"#mathematical-notation-parser","title":"\ud83d\udd24 Mathematical Notation Parser","text":"<p>Parse interval sets from strings using standard notation: <code>\"[0,5) \u222a (10,20] \u222a {25}\"</code>.</p>"},{"location":"#compile-time-interval-arithmetic","title":"\u26a1 Compile-Time Interval Arithmetic","text":"<p>Zero-overhead interval bounds checking at compile-time using template metaprogramming.</p>"},{"location":"#multi-dimensional-support","title":"\ud83d\udce6 Multi-Dimensional Support","text":"<p>Seamlessly extend to N-dimensional hyperrectangles for spatial and spatio-temporal problems.</p>"},{"location":"#rich-query-interface","title":"\ud83d\udd0d Rich Query Interface","text":"<p>Comprehensive predicates and queries: <code>gaps()</code>, <code>span()</code>, <code>density()</code>, <code>measure()</code>, and more.</p>"},{"location":"#performance","title":"\ud83d\ude80 Performance","text":"<ul> <li>O(log n) membership queries via binary search</li> <li>O(n + m) set operations via linear merge</li> <li>Automatic normalization maintains canonical form</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace dis;\n\nint main() {\n    // Define available time slots\n    auto availability = real_set{}\n        .add(9, 12)   // Morning: 9 AM - 12 PM\n        .add(14, 17); // Afternoon: 2 PM - 5 PM\n\n    // Parse meeting requests from mathematical notation\n    auto meetings = real_set::from_string(\"[10,11] \u222a [15,16]\");\n\n    // Calculate free time using set difference\n    auto free_time = availability - meetings;\n\n    // Query operations\n    std::cout &lt;&lt; \"Free time: \" &lt;&lt; free_time &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Total free hours: \" &lt;&lt; free_time.measure() &lt;&lt; '\\n';\n\n    // Calculate utilization\n    double utilization = meetings.measure() / availability.measure();\n    std::cout &lt;&lt; \"Utilization: \" &lt;&lt; (utilization * 100) &lt;&lt; \"%\\n\";\n\n    return 0;\n}\n</code></pre> <p>Output: <pre><code>Free time: [9,10) \u222a (11,12] \u222a [14,15) \u222a (16,17]\nTotal free hours: 4\nUtilization: 33.33%\n</code></pre></p>"},{"location":"#design-principles","title":"Design Principles","text":"<p>DIS follows Unix philosophy and modern C++ best practices:</p> <ol> <li>Simplicity: Every component does one thing exceptionally well</li> <li>Composability: Operations naturally compose together</li> <li>Mathematical Rigor: Models true mathematical concepts accurately</li> <li>Zero-Cost Abstractions: Template-based design with compile-time optimization</li> <li>Multiple Expression Styles: Support both mathematical and programming idioms</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>DIS is a header-only library with zero dependencies. Simply clone and include:</p> <pre><code>git clone https://github.com/yourusername/disjoint_interval_set.git\n</code></pre> <pre><code>#include &lt;dis/dis.hpp&gt;\n</code></pre> <p>Requirements: - C++17 or later (uses <code>std::optional</code>, structured bindings) - No external dependencies - Tested on GCC 9+, Clang 10+, MSVC 2019+</p>"},{"location":"#applications","title":"Applications","text":"<p>DIS excels in domains requiring interval manipulation:</p> <ul> <li>Computational Geometry: Polygon clipping, CSG operations</li> <li>Scheduling Systems: Resource allocation, conflict detection</li> <li>Numerical Analysis: Interval arithmetic, error bounds</li> <li>Access Control: Time-based permissions, IP range filtering</li> <li>Data Visualization: Histogram binning, range queries</li> <li>Signal Processing: Frequency band allocation</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>:material-rocket-launch: Getting Started</p> <p>Quick start guide with installation and your first program</p> </li> <li> <p>:material-book-open-variant: Technical Report</p> <p>In-depth technical documentation and mathematical foundations</p> </li> <li> <p>:material-code-braces: API Reference</p> <p>Complete API documentation for all classes and methods</p> </li> <li> <p>:material-school: User Guide</p> <p>Comprehensive tutorials and usage patterns</p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - See LICENSE for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this library in academic work, please cite:</p> <pre><code>@software{dis2025,\n  title = {Disjoint Interval Set: A Boolean Algebra for C++},\n  author = {Anonymous},\n  year = {2025},\n  url = {https://github.com/yourusername/disjoint_interval_set}\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Complete working examples demonstrating real-world usage of the DIS library.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/#example-1-time-slot-management","title":"Example 1: Time Slot Management","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace dis;\n\nint main() {\n    // Define available time slots\n    auto availability = real_set{}\n        .add(9, 12)   // Morning: 9 AM - 12 PM\n        .add(14, 17); // Afternoon: 2 PM - 5 PM\n\n    // Parse meeting requests\n    auto meetings = real_set::from_string(\"[10,11] \u222a [15,16]\");\n\n    // Calculate free time\n    auto free_time = availability - meetings;\n\n    // Display results\n    std::cout &lt;&lt; \"Availability: \" &lt;&lt; availability &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Meetings: \" &lt;&lt; meetings &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Free time: \" &lt;&lt; free_time &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Total free hours: \" &lt;&lt; free_time.measure() &lt;&lt; '\\n';\n\n    // Check specific times\n    if (availability.contains(10.5)) {\n        std::cout &lt;&lt; \"10:30 AM is available\\n\";\n    }\n\n    // Analyze gaps\n    auto gaps = meetings.gaps();\n    std::cout &lt;&lt; \"Gaps between meetings: \" &lt;&lt; gaps &lt;&lt; '\\n';\n\n    // Calculate utilization\n    double utilization = meetings.measure() / availability.measure();\n    std::cout &lt;&lt; \"Room utilization: \" &lt;&lt; (utilization * 100) &lt;&lt; \"%\\n\";\n\n    return 0;\n}\n</code></pre> <p>Output: <pre><code>Availability: [9,12] \u222a [14,17]\nMeetings: [10,11] \u222a [15,16]\nFree time: [9,10) \u222a (11,12] \u222a [14,15) \u222a (16,17]\nTotal free hours: 4\n10:30 AM is available\nGaps between meetings: (11,15)\nRoom utilization: 33.33%\n</code></pre></p>"},{"location":"examples/#scheduling-application","title":"Scheduling Application","text":""},{"location":"examples/#example-2-conference-room-scheduler","title":"Example 2: Conference Room Scheduler","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace dis;\n\nclass ConferenceRoomScheduler {\n    struct Room {\n        std::string name;\n        real_set schedule;\n        int capacity;\n    };\n\n    std::vector&lt;Room&gt; rooms_;\n    real_set business_hours_;\n\npublic:\n    ConferenceRoomScheduler()\n        : business_hours_(real_set{}\n            .add(8, 12)\n            .add(13, 18))  // 8 AM - 12 PM, 1 PM - 6 PM\n    {}\n\n    void add_room(const std::string&amp; name, int capacity) {\n        rooms_.push_back({name, real_set{}, capacity});\n    }\n\n    bool book_meeting(const std::string&amp; room_name,\n                     double start, double end,\n                     int required_capacity) {\n        auto meeting = real_interval::closed(start, end);\n\n        // Check business hours\n        if (!business_hours_.contains(start) ||\n            !business_hours_.contains(end - 0.01)) {\n            std::cout &lt;&lt; \"Outside business hours\\n\";\n            return false;\n        }\n\n        // Find room\n        for (auto&amp; room : rooms_) {\n            if (room.name == room_name) {\n                if (room.capacity &lt; required_capacity) {\n                    std::cout &lt;&lt; \"Insufficient capacity\\n\";\n                    return false;\n                }\n\n                // Check availability\n                if (!room.schedule.overlaps(real_set{meeting})) {\n                    room.schedule.insert(meeting);\n                    std::cout &lt;&lt; \"Booked: \" &lt;&lt; room_name\n                             &lt;&lt; \" from \" &lt;&lt; start &lt;&lt; \" to \" &lt;&lt; end &lt;&lt; '\\n';\n                    return true;\n                } else {\n                    std::cout &lt;&lt; \"Room not available\\n\";\n                    return false;\n                }\n            }\n        }\n\n        std::cout &lt;&lt; \"Room not found\\n\";\n        return false;\n    }\n\n    std::vector&lt;std::string&gt; find_available_rooms(double start, double end,\n                                                   int required_capacity) {\n        auto meeting = real_interval::closed(start, end);\n        std::vector&lt;std::string&gt; available;\n\n        for (const auto&amp; room : rooms_) {\n            if (room.capacity &gt;= required_capacity &amp;&amp;\n                !room.schedule.overlaps(real_set{meeting})) {\n                available.push_back(room.name);\n            }\n        }\n\n        return available;\n    }\n\n    void print_schedule() {\n        for (const auto&amp; room : rooms_) {\n            std::cout &lt;&lt; room.name &lt;&lt; \" (capacity: \" &lt;&lt; room.capacity &lt;&lt; \"): \"\n                     &lt;&lt; room.schedule &lt;&lt; '\\n';\n        }\n    }\n};\n\nint main() {\n    ConferenceRoomScheduler scheduler;\n\n    // Add rooms\n    scheduler.add_room(\"Room A\", 10);\n    scheduler.add_room(\"Room B\", 20);\n    scheduler.add_room(\"Room C\", 5);\n\n    // Book meetings\n    scheduler.book_meeting(\"Room A\", 9, 10, 8);   // Success\n    scheduler.book_meeting(\"Room A\", 9.5, 10.5, 8); // Conflict\n    scheduler.book_meeting(\"Room B\", 10, 11, 15); // Success\n    scheduler.book_meeting(\"Room C\", 14, 15, 3);  // Success\n\n    std::cout &lt;&lt; \"\\nFinal Schedule:\\n\";\n    scheduler.print_schedule();\n\n    std::cout &lt;&lt; \"\\nAvailable rooms for 11-12, capacity 10:\\n\";\n    auto available = scheduler.find_available_rooms(11, 12, 10);\n    for (const auto&amp; room : available) {\n        std::cout &lt;&lt; \"  \" &lt;&lt; room &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/#computational-geometry","title":"Computational Geometry","text":""},{"location":"examples/#example-3-1d-line-segment-operations","title":"Example 3: 1D Line Segment Operations","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace dis;\n\nvoid demonstrate_geometric_operations() {\n    // Define line segments\n    auto segment1 = real_set{real_interval::closed(0, 10)};\n    auto segment2 = real_set{real_interval::closed(5, 15)};\n    auto segment3 = real_set{real_interval::closed(20, 30)};\n\n    std::cout &lt;&lt; \"Segment 1: \" &lt;&lt; segment1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Segment 2: \" &lt;&lt; segment2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Segment 3: \" &lt;&lt; segment3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; '\\n';\n\n    // Union (coverage)\n    auto coverage = segment1 | segment2 | segment3;\n    std::cout &lt;&lt; \"Total coverage: \" &lt;&lt; coverage &lt;&lt; '\\n';\n\n    // Intersection (overlap)\n    auto overlap = segment1 &amp; segment2;\n    std::cout &lt;&lt; \"Overlap (1 &amp; 2): \" &lt;&lt; overlap &lt;&lt; '\\n';\n\n    // Symmetric difference (exclusive regions)\n    auto exclusive = segment1 ^ segment2;\n    std::cout &lt;&lt; \"Exclusive regions (1 ^ 2): \" &lt;&lt; exclusive &lt;&lt; '\\n';\n\n    // Measure calculations\n    std::cout &lt;&lt; \"\\nMeasures:\\n\";\n    std::cout &lt;&lt; \"Total coverage: \" &lt;&lt; coverage.measure() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Overlap: \" &lt;&lt; overlap.measure() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Exclusive: \" &lt;&lt; exclusive.measure() &lt;&lt; '\\n';\n\n    // Gap analysis\n    auto gaps = coverage.gaps();\n    std::cout &lt;&lt; \"\\nGaps in coverage: \" &lt;&lt; gaps &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Total gap measure: \" &lt;&lt; gaps.measure() &lt;&lt; '\\n';\n}\n\nint main() {\n    demonstrate_geometric_operations();\n    return 0;\n}\n</code></pre>"},{"location":"examples/#numerical-analysis","title":"Numerical Analysis","text":""},{"location":"examples/#example-4-interval-arithmetic-with-uncertainty","title":"Example 4: Interval Arithmetic with Uncertainty","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace dis;\n\nclass MeasurementWithUncertainty {\n    double center_;\n    double uncertainty_;\n\npublic:\n    MeasurementWithUncertainty(double center, double uncertainty)\n        : center_(center), uncertainty_(uncertainty) {}\n\n    real_interval as_interval() const {\n        return real_interval::closed(\n            center_ - uncertainty_,\n            center_ + uncertainty_\n        );\n    }\n\n    static MeasurementWithUncertainty from_interval(real_interval interval) {\n        double center = interval.midpoint();\n        double uncertainty = interval.length() / 2.0;\n        return MeasurementWithUncertainty(center, uncertainty);\n    }\n\n    MeasurementWithUncertainty operator+(const MeasurementWithUncertainty&amp; other) const {\n        auto i1 = as_interval();\n        auto i2 = other.as_interval();\n\n        double min = *i1.lower_bound() + *i2.lower_bound();\n        double max = *i1.upper_bound() + *i2.upper_bound();\n\n        return from_interval(real_interval::closed(min, max));\n    }\n\n    MeasurementWithUncertainty operator*(const MeasurementWithUncertainty&amp; other) const {\n        auto i1 = as_interval();\n        auto i2 = other.as_interval();\n\n        std::array products = {\n            *i1.lower_bound() * *i2.lower_bound(),\n            *i1.lower_bound() * *i2.upper_bound(),\n            *i1.upper_bound() * *i2.lower_bound(),\n            *i1.upper_bound() * *i2.upper_bound()\n        };\n\n        auto [min, max] = std::minmax_element(products.begin(), products.end());\n        return from_interval(real_interval::closed(*min, *max));\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MeasurementWithUncertainty&amp; m) {\n        os &lt;&lt; m.center_ &lt;&lt; \" \u00b1 \" &lt;&lt; m.uncertainty_;\n        return os;\n    }\n};\n\nint main() {\n    // Physical measurements with uncertainty\n    MeasurementWithUncertainty voltage(5.0, 0.1);    // 5V \u00b1 0.1V\n    MeasurementWithUncertainty current(2.0, 0.05);   // 2A \u00b1 0.05A\n\n    std::cout &lt;&lt; \"Voltage: \" &lt;&lt; voltage &lt;&lt; \"V\\n\";\n    std::cout &lt;&lt; \"Current: \" &lt;&lt; current &lt;&lt; \"A\\n\";\n\n    // Calculate power with propagated uncertainty\n    auto power = voltage * current;\n    std::cout &lt;&lt; \"Power: \" &lt;&lt; power &lt;&lt; \"W\\n\";\n\n    // Calculate total resistance in series\n    MeasurementWithUncertainty r1(100, 5);  // 100\u03a9 \u00b1 5\u03a9\n    MeasurementWithUncertainty r2(200, 10); // 200\u03a9 \u00b1 10\u03a9\n\n    auto total_r = r1 + r2;\n    std::cout &lt;&lt; \"\\nR1: \" &lt;&lt; r1 &lt;&lt; \"\u03a9\\n\";\n    std::cout &lt;&lt; \"R2: \" &lt;&lt; r2 &lt;&lt; \"\u03a9\\n\";\n    std::cout &lt;&lt; \"Total: \" &lt;&lt; total_r &lt;&lt; \"\u03a9\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/#access-control","title":"Access Control","text":""},{"location":"examples/#example-5-time-based-access-control-system","title":"Example 5: Time-Based Access Control System","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace dis;\n\nclass AccessControlSystem {\n    struct UserPolicy {\n        real_set allowed_times;\n        std::set&lt;std::string&gt; allowed_resources;\n    };\n\n    std::map&lt;std::string, UserPolicy&gt; policies_;\n\npublic:\n    void add_user(const std::string&amp; username) {\n        policies_[username] = UserPolicy{};\n    }\n\n    void grant_time_access(const std::string&amp; username,\n                          double start, double end) {\n        policies_[username].allowed_times.insert(\n            real_interval::closed(start, end)\n        );\n    }\n\n    void grant_resource_access(const std::string&amp; username,\n                              const std::string&amp; resource) {\n        policies_[username].allowed_resources.insert(resource);\n    }\n\n    void revoke_time_access(const std::string&amp; username,\n                           double start, double end) {\n        policies_[username].allowed_times.erase(\n            real_interval::closed(start, end)\n        );\n    }\n\n    bool can_access(const std::string&amp; username,\n                   const std::string&amp; resource,\n                   double time) {\n        auto it = policies_.find(username);\n        if (it == policies_.end()) return false;\n\n        const auto&amp; policy = it-&gt;second;\n        return policy.allowed_times.contains(time) &amp;&amp;\n               policy.allowed_resources.count(resource) &gt; 0;\n    }\n\n    void print_policy(const std::string&amp; username) {\n        auto it = policies_.find(username);\n        if (it == policies_.end()) {\n            std::cout &lt;&lt; \"User not found\\n\";\n            return;\n        }\n\n        const auto&amp; policy = it-&gt;second;\n        std::cout &lt;&lt; \"Policy for \" &lt;&lt; username &lt;&lt; \":\\n\";\n        std::cout &lt;&lt; \"  Allowed times: \" &lt;&lt; policy.allowed_times &lt;&lt; '\\n';\n        std::cout &lt;&lt; \"  Allowed resources: \";\n        for (const auto&amp; resource : policy.allowed_resources) {\n            std::cout &lt;&lt; resource &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; '\\n';\n    }\n};\n\nint main() {\n    AccessControlSystem acs;\n\n    // Setup users\n    acs.add_user(\"alice\");\n    acs.add_user(\"bob\");\n\n    // Alice: Full business hours access\n    acs.grant_time_access(\"alice\", 9, 17);\n    acs.grant_resource_access(\"alice\", \"database\");\n    acs.grant_resource_access(\"alice\", \"api\");\n\n    // Bob: Limited hours, lunch break excluded\n    acs.grant_time_access(\"bob\", 9, 12);\n    acs.grant_time_access(\"bob\", 13, 17);\n    acs.grant_resource_access(\"bob\", \"database\");\n\n    // Print policies\n    acs.print_policy(\"alice\");\n    acs.print_policy(\"bob\");\n\n    // Test access\n    std::cout &lt;&lt; \"\\nAccess Tests:\\n\";\n    std::cout &lt;&lt; \"Alice database @ 10:00: \"\n              &lt;&lt; (acs.can_access(\"alice\", \"database\", 10) ? \"GRANTED\" : \"DENIED\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Bob database @ 12:30: \"\n              &lt;&lt; (acs.can_access(\"bob\", \"database\", 12.5) ? \"GRANTED\" : \"DENIED\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Bob api @ 14:00: \"\n              &lt;&lt; (acs.can_access(\"bob\", \"api\", 14) ? \"GRANTED\" : \"DENIED\") &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/#complete-application","title":"Complete Application","text":""},{"location":"examples/#example-6-task-scheduler-with-dependencies","title":"Example 6: Task Scheduler with Dependencies","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace dis;\n\nstruct Task {\n    std::string name;\n    double duration;\n    std::vector&lt;std::string&gt; dependencies;\n    real_interval scheduled_time;\n};\n\nclass TaskScheduler {\n    std::vector&lt;Task&gt; tasks_;\n    std::map&lt;std::string, real_interval&gt; completion_times_;\n    real_set occupied_slots_;\n    real_set available_slots_;\n\npublic:\n    TaskScheduler(double start_time, double end_time)\n        : available_slots_(real_set{real_interval::closed(start_time, end_time)})\n    {}\n\n    void add_task(const std::string&amp; name,\n                 double duration,\n                 const std::vector&lt;std::string&gt;&amp; dependencies = {}) {\n        tasks_.push_back({name, duration, dependencies, real_interval::empty()});\n    }\n\n    bool schedule_all() {\n        // Topological sort for dependencies\n        std::vector&lt;Task*&gt; ready_tasks;\n\n        for (auto&amp; task : tasks_) {\n            if (task.dependencies.empty()) {\n                ready_tasks.push_back(&amp;task);\n            }\n        }\n\n        while (!ready_tasks.empty()) {\n            Task* task = ready_tasks.back();\n            ready_tasks.pop_back();\n\n            // Find earliest available slot\n            double earliest_start = 0.0;\n\n            // Check dependencies\n            for (const auto&amp; dep : task-&gt;dependencies) {\n                if (auto it = completion_times_.find(dep);\n                    it != completion_times_.end()) {\n                    earliest_start = std::max(earliest_start,\n                                            *it-&gt;second.upper_bound());\n                }\n            }\n\n            // Find slot in available times\n            for (const auto&amp; slot : available_slots_) {\n                double slot_start = *slot.lower_bound();\n                if (slot_start &gt;= earliest_start &amp;&amp;\n                    slot.length() &gt;= task-&gt;duration) {\n\n                    // Schedule task\n                    task-&gt;scheduled_time = real_interval::closed(\n                        slot_start,\n                        slot_start + task-&gt;duration\n                    );\n\n                    // Update occupied and available slots\n                    occupied_slots_.insert(task-&gt;scheduled_time);\n                    available_slots_ = available_slots_ - real_set{task-&gt;scheduled_time};\n\n                    // Mark completion time\n                    completion_times_[task-&gt;name] = task-&gt;scheduled_time;\n\n                    // Check if this completes dependencies for other tasks\n                    for (auto&amp; other : tasks_) {\n                        if (other.scheduled_time.is_empty() &amp;&amp;\n                            std::find(other.dependencies.begin(),\n                                    other.dependencies.end(),\n                                    task-&gt;name) != other.dependencies.end()) {\n\n                            // Check if all dependencies are done\n                            bool all_deps_done = true;\n                            for (const auto&amp; dep : other.dependencies) {\n                                if (completion_times_.find(dep) ==\n                                    completion_times_.end()) {\n                                    all_deps_done = false;\n                                    break;\n                                }\n                            }\n\n                            if (all_deps_done) {\n                                ready_tasks.push_back(&amp;other);\n                            }\n                        }\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // Check if all tasks were scheduled\n        return std::all_of(tasks_.begin(), tasks_.end(),\n                         [](const Task&amp; t) { return !t.scheduled_time.is_empty(); });\n    }\n\n    void print_schedule() {\n        std::cout &lt;&lt; \"Schedule:\\n\";\n        for (const auto&amp; task : tasks_) {\n            if (!task.scheduled_time.is_empty()) {\n                std::cout &lt;&lt; \"  \" &lt;&lt; task.name &lt;&lt; \": \"\n                         &lt;&lt; task.scheduled_time &lt;&lt; '\\n';\n            } else {\n                std::cout &lt;&lt; \"  \" &lt;&lt; task.name &lt;&lt; \": NOT SCHEDULED\\n\";\n            }\n        }\n\n        std::cout &lt;&lt; \"\\nUtilization: \"\n                 &lt;&lt; (occupied_slots_.measure() /\n                     (occupied_slots_ | available_slots_).span().length() * 100)\n                 &lt;&lt; \"%\\n\";\n    }\n};\n\nint main() {\n    TaskScheduler scheduler(0, 10);  // 10-hour window\n\n    // Add tasks with dependencies\n    scheduler.add_task(\"setup\", 1.0);\n    scheduler.add_task(\"compile\", 2.0, {\"setup\"});\n    scheduler.add_task(\"test\", 1.5, {\"compile\"});\n    scheduler.add_task(\"deploy\", 0.5, {\"test\"});\n    scheduler.add_task(\"docs\", 1.0, {\"setup\"});  // Parallel with compile\n\n    if (scheduler.schedule_all()) {\n        scheduler.print_schedule();\n    } else {\n        std::cout &lt;&lt; \"Failed to schedule all tasks\\n\";\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/#compile-and-run","title":"Compile and Run","text":"<p>All examples can be compiled with:</p> <pre><code>g++ -std=c++17 -I./include example.cpp -o example\n./example\n</code></pre> <p>For more examples, see the examples/ directory in the repository.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get up and running with the Disjoint Interval Set (DIS) library in minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>DIS is a header-only library with zero dependencies. Installation is as simple as copying the headers to your project.</p>"},{"location":"getting-started/#method-1-direct-include","title":"Method 1: Direct Include","text":"<pre><code># Clone the repository\ngit clone https://github.com/yourusername/disjoint_interval_set.git\n\n# Copy headers to your project\ncp -r disjoint_interval_set/include/dis /path/to/your/project/include/\n</code></pre>"},{"location":"getting-started/#method-2-submodule","title":"Method 2: Submodule","text":"<pre><code># Add as git submodule\ngit submodule add https://github.com/yourusername/disjoint_interval_set.git external/dis\n\n# In your CMakeLists.txt\ninclude_directories(external/dis/include)\n</code></pre>"},{"location":"getting-started/#method-3-system-wide-installation","title":"Method 3: System-Wide Installation","text":"<pre><code># Install to /usr/local/include\nsudo cp -r include/dis /usr/local/include/\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>C++17 or later (uses <code>std::optional</code>, structured bindings)</li> <li>No external dependencies</li> <li>Tested on:</li> <li>GCC 9+</li> <li>Clang 10+</li> <li>MSVC 2019+</li> <li>Apple Clang 12+</li> </ul>"},{"location":"getting-started/#your-first-program","title":"Your First Program","text":"<p>Create a file <code>example.cpp</code>:</p> <pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace dis;\n\nint main() {\n    // Create intervals using named constructors\n    auto morning = real_interval::closed(9, 12);\n    auto afternoon = real_interval::closed(14, 17);\n\n    // Build a set using fluent interface\n    auto work_hours = real_set{}\n        .add(morning)\n        .add(afternoon);\n\n    // Test membership\n    if (work_hours.contains(10.5)) {\n        std::cout &lt;&lt; \"10:30 AM is during work hours\\n\";\n    }\n\n    // Calculate total hours\n    std::cout &lt;&lt; \"Total work hours: \"\n              &lt;&lt; work_hours.measure() &lt;&lt; '\\n';\n\n    // Display the set\n    std::cout &lt;&lt; \"Work hours: \" &lt;&lt; work_hours &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/#compile-and-run","title":"Compile and Run","text":"<pre><code># GCC\ng++ -std=c++17 -I./include example.cpp -o example\n./example\n\n# Clang\nclang++ -std=c++17 -I./include example.cpp -o example\n./example\n\n# MSVC\ncl /std:c++17 /I.\\include example.cpp\nexample.exe\n</code></pre> <p>Output: <pre><code>10:30 AM is during work hours\nTotal work hours: 6\nWork hours: [9,12] \u222a [14,17]\n</code></pre></p>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#intervals","title":"Intervals","text":"<p>An interval represents a contiguous range of values with configurable boundaries:</p> <pre><code>// Closed interval: includes both endpoints\nauto closed = real_interval::closed(0, 10);        // [0, 10]\n\n// Open interval: excludes both endpoints\nauto open = real_interval::open(0, 10);           // (0, 10)\n\n// Half-open intervals\nauto left_open = real_interval::left_open(0, 10);  // (0, 10]\nauto right_open = real_interval::right_open(0, 10); // [0, 10)\n\n// Single point\nauto point = real_interval::point(5);              // {5}\n\n// Unbounded intervals (requires floating-point type)\nauto positive = real_interval::greater_than(0);    // (0, \u221e)\nauto at_least_zero = real_interval::at_least(0);   // [0, \u221e)\n</code></pre>"},{"location":"getting-started/#disjoint-interval-sets","title":"Disjoint Interval Sets","text":"<p>A disjoint interval set maintains a collection of non-overlapping intervals:</p> <pre><code>// Create empty set\nreal_set s;\n\n// Add intervals (automatically merged if overlapping)\ns.add(0, 10);     // [0, 10]\ns.add(20, 30);    // [0, 10] \u222a [20, 30]\ns.add(8, 22);     // [0, 30]  (merged all three!)\n\n// Check membership\nbool contains_15 = s.contains(15);  // true\n\n// Get number of disjoint components\nsize_t count = s.size();  // 1 (all merged)\n</code></pre>"},{"location":"getting-started/#set-operations","title":"Set Operations","text":"<p>DIS provides full Boolean algebra operations:</p> <pre><code>auto a = real_set::from_string(\"[0,10] \u222a [20,30]\");\nauto b = real_set::from_string(\"[5,15] \u222a [25,35]\");\n\n// Union\nauto union_ab = a | b;              // [0,15] \u222a [20,35]\n\n// Intersection\nauto intersect_ab = a &amp; b;          // [5,10] \u222a [25,30]\n\n// Complement\nauto not_a = ~a;                    // (-\u221e,0) \u222a (10,20) \u222a (30,\u221e)\n\n// Difference\nauto diff = a - b;                  // [0,5) \u222a (10,20) \u222a (30,35]\n\n// Symmetric difference\nauto sym_diff = a ^ b;              // [0,5) \u222a (10,15] \u222a [20,25) \u222a (30,35]\n</code></pre>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/#pattern-1-building-sets-incrementally","title":"Pattern 1: Building Sets Incrementally","text":"<pre><code>real_set schedule;\n\n// Add time slots\nschedule.add(9, 10);     // 9-10 AM\nschedule.add(11, 12);    // 11-12 PM\nschedule.add(14, 16);    // 2-4 PM\n\n// Add another slot (automatically merges if adjacent)\nschedule.add(10, 11);    // Now [9,12] \u222a [14,16]\n</code></pre>"},{"location":"getting-started/#pattern-2-parsing-from-strings","title":"Pattern 2: Parsing from Strings","text":"<pre><code>// Parse mathematical notation\nauto meetings = real_set::from_string(\"[10,11] \u222a [14,15]\");\n\n// Alternative notations\nauto same = real_set::from_string(\"[10,11] U [14,15]\");  // ASCII 'U'\nauto also = real_set::from_string(\"[10,11], [14,15]\");   // Comma-separated\n</code></pre>"},{"location":"getting-started/#pattern-3-filtering-intervals","title":"Pattern 3: Filtering Intervals","text":"<pre><code>auto set = real_set::from_string(\"[1,2] \u222a [5,20] \u222a [25,30]\");\n\n// Keep only intervals longer than 10\nauto large = set.filter([](const auto&amp; i) {\n    return i.length() &gt; 10;\n});\n// Result: [5,20]\n</code></pre>"},{"location":"getting-started/#pattern-4-analyzing-sets","title":"Pattern 4: Analyzing Sets","text":"<pre><code>auto set = real_set::from_string(\"[0,10] \u222a [20,30] \u222a [40,50]\");\n\n// Get span (smallest interval containing all)\nauto span = set.span();           // [0,50]\n\n// Get gaps between intervals\nauto gaps = set.gaps();           // [10,20] \u222a [30,40]\n\n// Calculate density\ndouble density = set.density();   // 0.6 (30/50)\n\n// Total measure (length)\ndouble total = set.measure();     // 30\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore more advanced topics:</p> <ul> <li>User Guide: Comprehensive tutorials</li> <li>API Reference: Detailed API documentation</li> <li>Examples: Real-world use cases</li> <li>Technical Report: In-depth theory and implementation</li> </ul>"},{"location":"getting-started/#quick-reference","title":"Quick Reference","text":""},{"location":"getting-started/#type-aliases","title":"Type Aliases","text":"<pre><code>using namespace dis;\n\n// Interval types\nreal_interval      // interval&lt;double&gt;\ninteger_interval   // interval&lt;int&gt;\n\n// Set types\nreal_set          // disjoint_interval_set&lt;real_interval&gt;\ninteger_set       // disjoint_interval_set&lt;integer_interval&gt;\n\n// Multi-dimensional\ntemplate&lt;typename T&gt; using rectangle = interval_nd&lt;T, 2&gt;;\ntemplate&lt;typename T&gt; using box = interval_nd&lt;T, 3&gt;;\n</code></pre>"},{"location":"getting-started/#common-operations","title":"Common Operations","text":"Operation Operator Method Union <code>a \\| b</code> <code>a.unite(b)</code> Intersection <code>a &amp; b</code> <code>a.intersect(b)</code> Complement <code>~a</code> <code>a.complement()</code> Difference <code>a - b</code> <code>a.difference(b)</code> Symmetric Diff <code>a ^ b</code> <code>a.symmetric_difference(b)</code>"},{"location":"getting-started/#factory-methods","title":"Factory Methods","text":"<pre><code>// Bounded intervals\ninterval::closed(a, b)         // [a, b]\ninterval::open(a, b)          // (a, b)\ninterval::left_open(a, b)     // (a, b]\ninterval::right_open(a, b)    // [a, b)\ninterval::point(x)            // {x}\n\n// Unbounded intervals\ninterval::unbounded()          // (-\u221e, \u221e)\ninterval::at_least(a)         // [a, \u221e)\ninterval::greater_than(a)     // (a, \u221e)\ninterval::at_most(b)          // (-\u221e, b]\ninterval::less_than(b)        // (-\u221e, b)\n</code></pre>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#compilation-errors","title":"Compilation Errors","text":"<p>Issue: <code>error: 'optional' is not a member of 'std'</code></p> <p>Solution: Ensure you're compiling with C++17 or later: <pre><code>g++ -std=c++17 ...\n</code></pre></p> <p>Issue: <code>error: no matching function for call to 'interval::unbounded()'</code></p> <p>Solution: Unbounded intervals require floating-point types with infinity support: <pre><code>real_interval::unbounded();   // OK (double has infinity)\ninteger_interval::unbounded(); // ERROR (int doesn't have infinity)\n</code></pre></p>"},{"location":"getting-started/#runtime-issues","title":"Runtime Issues","text":"<p>Issue: Intervals not merging as expected</p> <p>Check: Boundary types must match for merging: <pre><code>auto a = real_interval::closed(0, 10);      // [0, 10]\nauto b = real_interval::open(10, 20);       // (10, 20)\n// These are NOT adjacent (gap at 10), won't merge\n\nauto c = real_interval::right_open(0, 10);  // [0, 10)\nauto d = real_interval::closed(10, 20);     // [10, 20]\n// These ARE adjacent at 10, will merge to [0, 20]\n</code></pre></p>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Full API reference</li> <li>Examples: Complete examples</li> <li>Issues: Report bugs on GitHub</li> <li>Discussions: Ask questions in GitHub Discussions</li> </ul> <p>Happy interval computing!</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>Complete installation instructions for the Disjoint Interval Set library.</p>"},{"location":"installation/#overview","title":"Overview","text":"<p>DIS is a header-only library with zero dependencies. Installation simply involves making the headers available to your compiler.</p>"},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#compiler-requirements","title":"Compiler Requirements","text":"<ul> <li>C++17 or later (uses <code>std::optional</code>, <code>std::ranges</code> concepts, structured bindings)</li> <li>One of the following compilers:</li> <li>GCC 9.0 or later</li> <li>Clang 10.0 or later</li> <li>MSVC 2019 (19.20) or later</li> <li>Apple Clang 12.0 or later</li> </ul>"},{"location":"installation/#operating-systems","title":"Operating Systems","text":"<p>Tested on:</p> <ul> <li>Linux (Ubuntu 20.04+, Fedora 33+, Arch Linux)</li> <li>macOS 11.0+ (Big Sur and later)</li> <li>Windows 10/11 (with MSVC or MinGW-w64)</li> <li>FreeBSD 13.0+</li> </ul>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>None! DIS has zero external dependencies beyond the C++ standard library.</p>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-copy-headers-simplest","title":"Method 1: Copy Headers (Simplest)","text":"<p>The fastest way to start using DIS:</p> <pre><code># Clone the repository\ngit clone https://github.com/yourusername/disjoint_interval_set.git\n\n# Copy headers to your project's include directory\ncp -r disjoint_interval_set/include/dis /path/to/your/project/include/\n</code></pre> <p>Then include in your code:</p> <pre><code>#include &lt;dis/dis.hpp&gt;  // Main header (includes everything)\n\n// Or include specific components\n#include &lt;dis/core/interval.hpp&gt;\n#include &lt;dis/core/disjoint_interval_set.hpp&gt;\n</code></pre>"},{"location":"installation/#method-2-git-submodule","title":"Method 2: Git Submodule","text":"<p>For projects using Git:</p> <pre><code># Add DIS as a submodule\ngit submodule add https://github.com/yourusername/disjoint_interval_set.git external/dis\ngit submodule update --init --recursive\n</code></pre>"},{"location":"installation/#with-cmake","title":"With CMake","text":"<pre><code># CMakeLists.txt\ncmake_minimum_required(VERSION 3.14)\nproject(MyProject)\n\n# Add DIS include directory\ninclude_directories(external/dis/include)\n\n# Your executable\nadd_executable(my_app main.cpp)\ntarget_compile_features(my_app PRIVATE cxx_std_17)\n</code></pre>"},{"location":"installation/#with-makefile","title":"With Makefile","text":"<pre><code># Makefile\nCXX = g++\nCXXFLAGS = -std=c++17 -Wall -O2\nINCLUDES = -Iexternal/dis/include\n\nmy_app: main.cpp\n    $(CXX) $(CXXFLAGS) $(INCLUDES) main.cpp -o my_app\n</code></pre>"},{"location":"installation/#method-3-system-wide-installation","title":"Method 3: System-Wide Installation","text":"<p>Install headers system-wide (requires root):</p>"},{"location":"installation/#linuxmacos","title":"Linux/macOS","text":"<pre><code># Clone repository\ngit clone https://github.com/yourusername/disjoint_interval_set.git\ncd disjoint_interval_set\n\n# Install to /usr/local/include\nsudo cp -r include/dis /usr/local/include/\n\n# Or to a custom prefix\nPREFIX=$HOME/.local\nmkdir -p $PREFIX/include\ncp -r include/dis $PREFIX/include/\n</code></pre>"},{"location":"installation/#windows-administrator-powershell","title":"Windows (Administrator PowerShell)","text":"<pre><code># Clone repository\ngit clone https://github.com/yourusername/disjoint_interval_set.git\ncd disjoint_interval_set\n\n# Copy to MSVC include directory\n$VS_PATH = \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\&lt;version&gt;\\include\"\nCopy-Item -Recurse include\\dis \"$VS_PATH\\dis\"\n</code></pre>"},{"location":"installation/#method-4-package-managers","title":"Method 4: Package Managers","text":""},{"location":"installation/#conan-coming-soon","title":"Conan (Coming Soon)","text":"<pre><code># In conanfile.txt\n[requires]\ndisjoint_interval_set/1.0.0\n\n[generators]\ncmake\n</code></pre>"},{"location":"installation/#vcpkg-coming-soon","title":"vcpkg (Coming Soon)","text":"<pre><code>vcpkg install disjoint-interval-set\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":""},{"location":"installation/#test-installation","title":"Test Installation","text":"<p>Create <code>test.cpp</code>:</p> <pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    using namespace dis;\n\n    auto interval = real_interval::closed(0, 10);\n    std::cout &lt;&lt; \"Interval: \" &lt;&lt; interval &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Contains 5: \" &lt;&lt; std::boolalpha &lt;&lt; interval.contains(5) &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> <p>Compile and run:</p> <pre><code># GCC/Clang\ng++ -std=c++17 test.cpp -o test\n./test\n\n# Expected output:\n# Interval: [0,10]\n# Contains 5: true\n</code></pre>"},{"location":"installation/#run-test-suite","title":"Run Test Suite","text":"<p>To verify the installation with the full test suite:</p> <pre><code># Clone repository\ngit clone https://github.com/yourusername/disjoint_interval_set.git\ncd disjoint_interval_set\n\n# Build tests\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n\n# Run tests\nctest --verbose\n</code></pre> <p>Expected output: <pre><code>Test project /path/to/build\n    Start 1: test_interval_comprehensive\n1/3 Test #1: test_interval_comprehensive ......   Passed    0.05 sec\n    Start 2: test_dis_comprehensive\n2/3 Test #2: test_dis_comprehensive ...........   Passed    0.08 sec\n    Start 3: test_elegant_api\n3/3 Test #3: test_elegant_api .................   Passed    0.03 sec\n\n100% tests passed, 0 tests failed out of 3\n</code></pre></p>"},{"location":"installation/#ide-setup","title":"IDE Setup","text":""},{"location":"installation/#visual-studio-code","title":"Visual Studio Code","text":"<p>Create <code>.vscode/c_cpp_properties.json</code>:</p> <pre><code>{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\",\n                \"${workspaceFolder}/external/dis/include\"\n            ],\n            \"defines\": [],\n            \"compilerPath\": \"/usr/bin/g++\",\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"linux-gcc-x64\"\n        }\n    ],\n    \"version\": 4\n}\n</code></pre>"},{"location":"installation/#clion","title":"CLion","text":"<p>CMake configuration is automatically detected from <code>CMakeLists.txt</code>.</p>"},{"location":"installation/#visual-studio","title":"Visual Studio","text":"<ol> <li>Open project properties</li> <li>Go to C/C++ \u2192 General \u2192 Additional Include Directories</li> <li>Add path to <code>dis/include</code></li> <li>Go to C/C++ \u2192 Language \u2192 C++ Language Standard</li> <li>Set to ISO C++17 or later</li> </ol>"},{"location":"installation/#xcode","title":"Xcode","text":"<ol> <li>Select target \u2192 Build Settings</li> <li>Search for \"Header Search Paths\"</li> <li>Add path to <code>dis/include</code></li> <li>Search for \"C++ Language Dialect\"</li> <li>Set to C++17 or later</li> </ol>"},{"location":"installation/#build-system-integration","title":"Build System Integration","text":""},{"location":"installation/#cmake","title":"CMake","text":"<pre><code>cmake_minimum_required(VERSION 3.14)\nproject(MyProject CXX)\n\n# Option 1: Add as subdirectory (if using git submodule)\nadd_subdirectory(external/dis)\n\n# Option 2: Find installed package\nfind_package(dis REQUIRED)\n\n# Your target\nadd_executable(my_app src/main.cpp)\ntarget_link_libraries(my_app PRIVATE dis::dis)\ntarget_compile_features(my_app PRIVATE cxx_std_17)\n</code></pre>"},{"location":"installation/#meson","title":"Meson","text":"<pre><code>project('myproject', 'cpp',\n  default_options: ['cpp_std=c++17'])\n\ndis_dep = declare_dependency(\n  include_directories: include_directories('external/dis/include'))\n\nexecutable('my_app',\n  sources: 'main.cpp',\n  dependencies: [dis_dep])\n</code></pre>"},{"location":"installation/#bazel","title":"Bazel","text":"<pre><code># WORKSPACE\nload(\"@bazel_tools//tools/build_defs/repo:git.bzl\", \"git_repository\")\n\ngit_repository(\n    name = \"dis\",\n    remote = \"https://github.com/yourusername/disjoint_interval_set.git\",\n    tag = \"v1.0.0\",\n)\n\n# BUILD\ncc_binary(\n    name = \"my_app\",\n    srcs = [\"main.cpp\"],\n    deps = [\"@dis//:dis\"],\n)\n</code></pre>"},{"location":"installation/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"installation/#compiler-flags","title":"Compiler Flags","text":""},{"location":"installation/#optimization","title":"Optimization","text":"<pre><code># Development (fast compilation, debug info)\ng++ -std=c++17 -O0 -g main.cpp\n\n# Release (maximum optimization)\ng++ -std=c++17 -O3 -DNDEBUG main.cpp\n\n# With native CPU optimizations\ng++ -std=c++17 -O3 -march=native main.cpp\n</code></pre>"},{"location":"installation/#warnings","title":"Warnings","text":"<pre><code># Recommended warning flags\ng++ -std=c++17 -Wall -Wextra -Wpedantic main.cpp\n\n# Stricter warnings\nclang++ -std=c++17 -Weverything -Wno-c++98-compat main.cpp\n</code></pre>"},{"location":"installation/#custom-namespace","title":"Custom Namespace","text":"<p>By default, all DIS symbols are in the <code>dis</code> namespace. To avoid conflicts:</p> <pre><code>// Option 1: Use namespace alias\nnamespace my_dis = dis;\n\n// Option 2: Selective imports\nusing dis::real_interval;\nusing dis::real_set;\n</code></pre>"},{"location":"installation/#static-vs-dynamic-linking","title":"Static vs Dynamic Linking","text":"<p>DIS is header-only, so there's no choice between static and dynamic linking. However, if you create a wrapper library:</p> <pre><code># Create a static library wrapper (optional)\nadd_library(dis_wrapper STATIC src/dis_wrapper.cpp)\ntarget_include_directories(dis_wrapper PUBLIC external/dis/include)\ntarget_compile_features(dis_wrapper PUBLIC cxx_std_17)\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#issue-disdishpp-no-such-file-or-directory","title":"Issue: \"dis/dis.hpp: No such file or directory\"","text":"<p>Solution: Ensure include path is set correctly:</p> <pre><code># Check include path\ng++ -std=c++17 -I./include test.cpp\n\n# Or for system-wide installation\ng++ -std=c++17 -I/usr/local/include test.cpp\n</code></pre>"},{"location":"installation/#issue-c17-features-not-available","title":"Issue: C++17 features not available","text":"<p>Solution: Explicitly enable C++17:</p> <pre><code># GCC/Clang\ng++ -std=c++17 ...\nclang++ -std=c++17 ...\n\n# MSVC\ncl /std:c++17 ...\n</code></pre>"},{"location":"installation/#issue-linker-errors-with-stdoptional","title":"Issue: Linker errors with std::optional","text":"<p>Solution: On some older systems, may need to link against C++ filesystem library:</p> <pre><code>g++ -std=c++17 test.cpp -lstdc++fs\n</code></pre>"},{"location":"installation/#issue-slow-compilation-times","title":"Issue: Slow compilation times","text":"<p>Solutions:</p> <ol> <li>Use precompiled headers</li> <li>Include only what you need:    <pre><code>#include &lt;dis/core/interval.hpp&gt;  // Instead of &lt;dis/dis.hpp&gt;\n</code></pre></li> <li>Enable ccache:    <pre><code>export CXX=\"ccache g++\"\n</code></pre></li> </ol>"},{"location":"installation/#platform-specific-issues","title":"Platform-Specific Issues","text":""},{"location":"installation/#macos-xcode-command-line-tools","title":"macOS: Xcode Command Line Tools","text":"<p>Ensure Xcode CLT are installed:</p> <pre><code>xcode-select --install\n</code></pre>"},{"location":"installation/#windows-mingw-path-issues","title":"Windows: MinGW PATH Issues","text":"<p>Add MinGW to PATH:</p> <pre><code>$env:Path += \";C:\\mingw64\\bin\"\n</code></pre>"},{"location":"installation/#linux-old-gcc-version","title":"Linux: Old GCC Version","text":"<p>Update GCC on Ubuntu/Debian:</p> <pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt update\nsudo apt install gcc-11 g++-11\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once installed, proceed to:</p> <ul> <li>Getting Started Guide: Your first program</li> <li>API Reference: Detailed documentation</li> <li>Examples: Real-world use cases</li> </ul>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":"<p>To remove DIS:</p> <pre><code># If installed system-wide\nsudo rm -rf /usr/local/include/dis\n\n# If using git submodule\ngit submodule deinit external/dis\ngit rm external/dis\nrm -rf .git/modules/external/dis\n</code></pre>"},{"location":"about/citation/","title":"Citation","text":"<p>If you use the Disjoint Interval Set library in your research or publications, please cite:</p>"},{"location":"about/citation/#bibtex","title":"BibTeX","text":"<pre><code>@software{dis2025,\n  title = {Disjoint Interval Set: A Boolean Algebra for C++},\n  author = {Anonymous},\n  year = {2025},\n  url = {https://github.com/yourusername/disjoint_interval_set},\n  version = {1.0.0}\n}\n</code></pre>"},{"location":"about/citation/#apa-style","title":"APA Style","text":"<p>Anonymous. (2025). Disjoint Interval Set: A Boolean Algebra for C++ (Version 1.0.0) [Computer software]. https://github.com/yourusername/disjoint_interval_set</p>"},{"location":"about/citation/#ieee-style","title":"IEEE Style","text":"<p>Anonymous, \"Disjoint Interval Set: A Boolean Algebra for C++,\" 2025. [Online]. Available: https://github.com/yourusername/disjoint_interval_set</p>"},{"location":"about/citation/#chicago-style","title":"Chicago Style","text":"<p>Anonymous. 2025. \"Disjoint Interval Set: A Boolean Algebra for C++.\" Version 1.0.0. https://github.com/yourusername/disjoint_interval_set.</p>"},{"location":"about/citation/#citing-the-technical-report","title":"Citing the Technical Report","text":"<p>If you reference the technical report specifically:</p> <pre><code>@techreport{dis_technical_report2025,\n  title = {Disjoint Interval Sets: A Boolean Algebra for C++},\n  author = {Anonymous},\n  institution = {},\n  year = {2025},\n  type = {Technical Report},\n  url = {https://github.com/yourusername/disjoint_interval_set/blob/master/TECHNICAL_REPORT.md}\n}\n</code></pre>"},{"location":"about/citation/#acknowledgment-in-text","title":"Acknowledgment in Text","text":"<p>If a full citation is not appropriate, please acknowledge the library in your text:</p> <p>This work uses the Disjoint Interval Set (DIS) library [https://github.com/yourusername/disjoint_interval_set].</p>"},{"location":"about/contributing/","title":"Contributing to DIS","text":"<p>We welcome contributions! This guide will help you get started.</p>"},{"location":"about/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>\ud83d\udc1b Report bugs: Open an issue describing the problem</li> <li>\ud83d\udca1 Suggest features: Share your ideas for improvements</li> <li>\ud83d\udcdd Improve documentation: Fix typos, add examples, clarify explanations</li> <li>\ud83d\udd27 Submit code: Implement features or fix bugs</li> <li>\u2705 Write tests: Increase test coverage</li> <li>\ud83d\udcca Benchmarking: Compare performance with other libraries</li> </ul>"},{"location":"about/contributing/#development-setup","title":"Development Setup","text":""},{"location":"about/contributing/#clone-repository","title":"Clone Repository","text":"<pre><code>git clone https://github.com/yourusername/disjoint_interval_set.git\ncd disjoint_interval_set\n</code></pre>"},{"location":"about/contributing/#build-tests","title":"Build Tests","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\nctest\n</code></pre>"},{"location":"about/contributing/#code-style","title":"Code Style","text":"<p>Follow these guidelines:</p> <ul> <li>C++ Standard: C++17 minimum, prefer C++20 features when available</li> <li>Naming: <code>snake_case</code> for functions/variables, <code>PascalCase</code> for types</li> <li>Const correctness: Mark methods <code>const</code> when they don't modify state</li> <li>Documentation: Use Doxygen-style comments for public APIs</li> <li>Testing: Write comprehensive tests for new features</li> </ul>"},{"location":"about/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create branch: <code>git checkout -b feature/amazing-feature</code></li> <li>Commit changes: <code>git commit -m 'Add amazing feature'</code></li> <li>Push: <code>git push origin feature/amazing-feature</code></li> <li>Open PR: Submit pull request with clear description</li> </ol>"},{"location":"about/contributing/#license","title":"License","text":"<p>By contributing, you agree your contributions will be licensed under the MIT License.</p>"},{"location":"about/license/","title":"License","text":"<p>The Disjoint Interval Set library is released under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 [Author Name]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"about/license/#why-mit","title":"Why MIT?","text":"<p>The MIT License was chosen for maximum freedom and compatibility:</p> <ul> <li>Permissive: Allows commercial and private use</li> <li>Simple: Easy to understand, no complex legal language</li> <li>Compatible: Works with most other licenses</li> <li>Academic Friendly: Suitable for research and education</li> <li>Industry Standard: Widely used and accepted</li> </ul>"},{"location":"about/license/#what-this-means-for-you","title":"What This Means for You","text":""},{"location":"about/license/#you-can","title":"You CAN:","text":"<ul> <li>\u2705 Use the library in commercial products</li> <li>\u2705 Modify the source code</li> <li>\u2705 Distribute the library</li> <li>\u2705 Use it in proprietary software</li> <li>\u2705 Sublicense it</li> <li>\u2705 Include it in closed-source projects</li> </ul>"},{"location":"about/license/#you-must","title":"You MUST:","text":"<ul> <li>\ud83d\udccb Include the copyright notice and license text</li> <li>\ud83d\udccb Provide attribution in your documentation</li> </ul>"},{"location":"about/license/#you-cannot","title":"You CANNOT:","text":"<ul> <li>\u274c Hold the authors liable for any damages</li> <li>\u274c Use authors' names for endorsement without permission</li> </ul>"},{"location":"about/license/#third-party-dependencies","title":"Third-Party Dependencies","text":"<p>DIS has zero dependencies beyond the C++ standard library, which is typically licensed by your compiler vendor:</p> <ul> <li>GCC libstdc++: GPL with Runtime Library Exception</li> <li>LLVM libc++: MIT License</li> <li>MSVC STL: Microsoft proprietary, free for use with MSVC</li> </ul>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to DIS, you agree that your contributions will be licensed under the same MIT License. See Contributing for details.</p>"},{"location":"api/disjoint-interval-set/","title":"Disjoint Interval Set API Reference","text":"<p>Complete API documentation for the <code>disjoint_interval_set&lt;I&gt;</code> class template.</p>"},{"location":"api/disjoint-interval-set/#class-template","title":"Class Template","text":"<pre><code>template&lt;typename I&gt;\nclass disjoint_interval_set;\n</code></pre>"},{"location":"api/disjoint-interval-set/#template-parameters","title":"Template Parameters","text":"<ul> <li>I: The interval type. Typically <code>interval&lt;T&gt;</code>.</li> </ul>"},{"location":"api/disjoint-interval-set/#common-type-aliases","title":"Common Type Aliases","text":"<pre><code>namespace dis {\n    using real_set = disjoint_interval_set&lt;real_interval&gt;;\n    using integer_set = disjoint_interval_set&lt;integer_interval&gt;;\n}\n</code></pre>"},{"location":"api/disjoint-interval-set/#constructors","title":"Constructors","text":""},{"location":"api/disjoint-interval-set/#default-constructor","title":"Default Constructor","text":"<pre><code>disjoint_interval_set() = default;\n</code></pre>"},{"location":"api/disjoint-interval-set/#from-interval","title":"From Interval","text":"<pre><code>explicit disjoint_interval_set(I interval);\n</code></pre>"},{"location":"api/disjoint-interval-set/#from-initializer-list","title":"From Initializer List","text":"<pre><code>disjoint_interval_set(std::initializer_list&lt;I&gt; intervals);\n</code></pre>"},{"location":"api/disjoint-interval-set/#from-range","title":"From Range","text":"<pre><code>template&lt;std::ranges::input_range R&gt;\nexplicit disjoint_interval_set(R&amp;&amp; range);\n</code></pre>"},{"location":"api/disjoint-interval-set/#named-constructors","title":"Named Constructors","text":""},{"location":"api/disjoint-interval-set/#empty","title":"<code>empty()</code>","text":"<pre><code>[[nodiscard]] static disjoint_interval_set empty();\n</code></pre>"},{"location":"api/disjoint-interval-set/#from_stringstdstring_view-str","title":"<code>from_string(std::string_view str)</code>","text":"<p><pre><code>[[nodiscard]] static disjoint_interval_set from_string(std::string_view str);\n</code></pre> Parses mathematical notation like <code>\"[0,5) \u222a (10,20]\"</code>.</p>"},{"location":"api/disjoint-interval-set/#core-operations","title":"Core Operations","text":""},{"location":"api/disjoint-interval-set/#queries","title":"Queries","text":""},{"location":"api/disjoint-interval-set/#is_empty","title":"<code>is_empty()</code>","text":"<pre><code>[[nodiscard]] bool is_empty() const noexcept;\n</code></pre>"},{"location":"api/disjoint-interval-set/#size","title":"<code>size()</code>","text":"<p><pre><code>[[nodiscard]] size_type size() const noexcept;\n</code></pre> Returns number of disjoint intervals.</p>"},{"location":"api/disjoint-interval-set/#containsvalue_type-value","title":"<code>contains(value_type value)</code>","text":"<p><pre><code>[[nodiscard]] bool contains(value_type value) const;\n</code></pre> Tests membership. O(log n) via binary search.</p>"},{"location":"api/disjoint-interval-set/#overlapsconst-disjoint_interval_set-other","title":"<code>overlaps(const disjoint_interval_set&amp; other)</code>","text":"<pre><code>[[nodiscard]] bool overlaps(const disjoint_interval_set&amp; other) const;\n</code></pre>"},{"location":"api/disjoint-interval-set/#set-operations","title":"Set Operations","text":"<p>All operations return a new set (value semantics).</p>"},{"location":"api/disjoint-interval-set/#union","title":"Union","text":"<pre><code>disjoint_interval_set unite(const disjoint_interval_set&amp; other) const;\nfriend disjoint_interval_set operator|(const disjoint_interval_set&amp; a,\n                                       const disjoint_interval_set&amp; b);\n</code></pre>"},{"location":"api/disjoint-interval-set/#intersection","title":"Intersection","text":"<pre><code>disjoint_interval_set intersect(const disjoint_interval_set&amp; other) const;\nfriend disjoint_interval_set operator&amp;(const disjoint_interval_set&amp; a,\n                                       const disjoint_interval_set&amp; b);\n</code></pre>"},{"location":"api/disjoint-interval-set/#complement","title":"Complement","text":"<pre><code>disjoint_interval_set complement() const;\nfriend disjoint_interval_set operator~(const disjoint_interval_set&amp; a);\n</code></pre>"},{"location":"api/disjoint-interval-set/#difference","title":"Difference","text":"<pre><code>disjoint_interval_set difference(const disjoint_interval_set&amp; other) const;\nfriend disjoint_interval_set operator-(const disjoint_interval_set&amp; a,\n                                       const disjoint_interval_set&amp; b);\n</code></pre>"},{"location":"api/disjoint-interval-set/#symmetric-difference","title":"Symmetric Difference","text":"<pre><code>disjoint_interval_set symmetric_difference(const disjoint_interval_set&amp; other) const;\nfriend disjoint_interval_set operator^(const disjoint_interval_set&amp; a,\n                                       const disjoint_interval_set&amp; b);\n</code></pre>"},{"location":"api/disjoint-interval-set/#fluent-interface","title":"Fluent Interface","text":""},{"location":"api/disjoint-interval-set/#addi-interval-addt-lower-t-upper","title":"<code>add(I interval)</code> / <code>add(T lower, T upper)</code>","text":"<pre><code>disjoint_interval_set&amp; add(I interval) &amp;;\ndisjoint_interval_set&amp;&amp; add(I interval) &amp;&amp;;\ndisjoint_interval_set&amp; add(value_type lower, value_type upper) &amp;;\n</code></pre>"},{"location":"api/disjoint-interval-set/#removei-interval-erasei-interval","title":"<code>remove(I interval)</code> / <code>erase(I interval)</code>","text":"<pre><code>disjoint_interval_set&amp; remove(I interval) &amp;;\ndisjoint_interval_set&amp; erase(I interval) &amp;;\n</code></pre>"},{"location":"api/disjoint-interval-set/#analysis-operations","title":"Analysis Operations","text":""},{"location":"api/disjoint-interval-set/#span","title":"<code>span()</code>","text":"<p><pre><code>[[nodiscard]] I span() const;\n</code></pre> Returns smallest interval containing all intervals.</p>"},{"location":"api/disjoint-interval-set/#gaps","title":"<code>gaps()</code>","text":"<p><pre><code>[[nodiscard]] disjoint_interval_set gaps() const;\n</code></pre> Returns intervals between components.</p>"},{"location":"api/disjoint-interval-set/#measure","title":"<code>measure()</code>","text":"<p><pre><code>[[nodiscard]] value_type measure() const;\n</code></pre> Returns total length.</p>"},{"location":"api/disjoint-interval-set/#density","title":"<code>density()</code>","text":"<p><pre><code>[[nodiscard]] double density() const;\n</code></pre> Returns <code>measure() / span().length()</code>.</p>"},{"location":"api/disjoint-interval-set/#functional-operations","title":"Functional Operations","text":""},{"location":"api/disjoint-interval-set/#filterpredicate-pred","title":"<code>filter(Predicate pred)</code>","text":"<pre><code>template&lt;typename Predicate&gt;\ndisjoint_interval_set filter(Predicate pred) const;\n</code></pre>"},{"location":"api/disjoint-interval-set/#for_eachfunction-fn","title":"<code>for_each(Function fn)</code>","text":"<pre><code>template&lt;typename Function&gt;\nvoid for_each(Function fn) const;\n</code></pre>"},{"location":"api/disjoint-interval-set/#iteration","title":"Iteration","text":"<pre><code>const_iterator begin() const noexcept;\nconst_iterator end() const noexcept;\n</code></pre> <p>Use in range-based for loops: <pre><code>for (const auto&amp; interval : my_set) {\n    // Process interval\n}\n</code></pre></p>"},{"location":"api/disjoint-interval-set/#complete-example","title":"Complete Example","text":"<p>See Examples for comprehensive usage examples.</p>"},{"location":"api/interval/","title":"Interval API Reference","text":"<p>Complete API documentation for the <code>interval&lt;T&gt;</code> class template.</p>"},{"location":"api/interval/#class-template","title":"Class Template","text":"<pre><code>template&lt;Boundary T&gt;\nclass interval;\n</code></pre>"},{"location":"api/interval/#template-parameters","title":"Template Parameters","text":"<ul> <li>T: The value type for interval boundaries. Must satisfy the <code>Boundary</code> concept (totally ordered and regular).</li> </ul>"},{"location":"api/interval/#common-type-aliases","title":"Common Type Aliases","text":"<pre><code>namespace dis {\n    using real_interval = interval&lt;double&gt;;\n    using integer_interval = interval&lt;int&gt;;\n}\n</code></pre>"},{"location":"api/interval/#named-constructors-factory-methods","title":"Named Constructors (Factory Methods)","text":""},{"location":"api/interval/#bounded-intervals","title":"Bounded Intervals","text":""},{"location":"api/interval/#closedt-lower-t-upper","title":"<code>closed(T lower, T upper)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval closed(T lower, T upper) noexcept;\n</code></pre> Creates a closed interval \\([a, b]\\) that includes both endpoints.</p> <p>Example: <pre><code>auto i = real_interval::closed(0, 10);  // [0, 10]\nassert(i.contains(0));   // true\nassert(i.contains(10));  // true\n</code></pre></p>"},{"location":"api/interval/#opent-lower-t-upper","title":"<code>open(T lower, T upper)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval open(T lower, T upper) noexcept;\n</code></pre> Creates an open interval \\((a, b)\\) that excludes both endpoints.</p> <p>Example: <pre><code>auto i = real_interval::open(0, 10);  // (0, 10)\nassert(!i.contains(0));   // false\nassert(!i.contains(10));  // false\nassert(i.contains(5));    // true\n</code></pre></p>"},{"location":"api/interval/#left_opent-lower-t-upper","title":"<code>left_open(T lower, T upper)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval left_open(T lower, T upper) noexcept;\n</code></pre> Creates a left-open interval \\((a, b]\\).</p>"},{"location":"api/interval/#right_opent-lower-t-upper","title":"<code>right_open(T lower, T upper)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval right_open(T lower, T upper) noexcept;\n</code></pre> Creates a right-open interval \\([a, b)\\).</p>"},{"location":"api/interval/#special-intervals","title":"Special Intervals","text":""},{"location":"api/interval/#pointt-value","title":"<code>point(T value)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval point(T value) noexcept;\n</code></pre> Creates a singleton interval \\(\\{x\\}\\) containing exactly one point.</p>"},{"location":"api/interval/#empty","title":"<code>empty()</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval empty() noexcept;\n</code></pre> Creates an empty interval \\(\\emptyset\\).</p>"},{"location":"api/interval/#unbounded-intervals","title":"Unbounded Intervals","text":"<p>Requires <code>std::numeric_limits&lt;T&gt;::has_infinity</code>.</p>"},{"location":"api/interval/#unbounded","title":"<code>unbounded()</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval unbounded() noexcept;\n</code></pre> Creates \\((-\\infty, \\infty)\\).</p>"},{"location":"api/interval/#at_leastt-lower","title":"<code>at_least(T lower)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval at_least(T lower) noexcept;\n</code></pre> Creates \\([a, \\infty)\\).</p>"},{"location":"api/interval/#greater_thant-lower","title":"<code>greater_than(T lower)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval greater_than(T lower) noexcept;\n</code></pre> Creates \\((a, \\infty)\\).</p>"},{"location":"api/interval/#at_mostt-upper","title":"<code>at_most(T upper)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval at_most(T upper) noexcept;\n</code></pre> Creates \\((-\\infty, b]\\).</p>"},{"location":"api/interval/#less_thant-upper","title":"<code>less_than(T upper)</code>","text":"<p><pre><code>[[nodiscard]] static constexpr interval less_than(T upper) noexcept;\n</code></pre> Creates \\((-\\infty, b)\\).</p>"},{"location":"api/interval/#member-functions","title":"Member Functions","text":""},{"location":"api/interval/#queries","title":"Queries","text":""},{"location":"api/interval/#is_empty","title":"<code>is_empty()</code>","text":"<p><pre><code>constexpr bool is_empty() const noexcept;\n</code></pre> Returns <code>true</code> if interval contains no points.</p>"},{"location":"api/interval/#containst-value","title":"<code>contains(T value)</code>","text":"<p><pre><code>constexpr bool contains(T value) const;\n</code></pre> Tests if value is in interval.</p>"},{"location":"api/interval/#overlapsconst-interval-other","title":"<code>overlaps(const interval&amp; other)</code>","text":"<p><pre><code>constexpr bool overlaps(const interval&amp; other) const;\n</code></pre> Tests if intervals have non-empty intersection.</p>"},{"location":"api/interval/#accessors","title":"Accessors","text":""},{"location":"api/interval/#lower_bound-upper_bound","title":"<code>lower_bound()</code>, <code>upper_bound()</code>","text":"<p><pre><code>constexpr std::optional&lt;T&gt; lower_bound() const noexcept;\nconstexpr std::optional&lt;T&gt; upper_bound() const noexcept;\n</code></pre> Returns bounds, or <code>std::nullopt</code> for empty intervals.</p>"},{"location":"api/interval/#measures","title":"Measures","text":"<p>(Requires <code>std::is_arithmetic_v&lt;T&gt;</code>)</p>"},{"location":"api/interval/#length","title":"<code>length()</code>","text":"<p><pre><code>constexpr T length() const;\n</code></pre> Returns \\(b - a\\).</p>"},{"location":"api/interval/#midpoint","title":"<code>midpoint()</code>","text":"<p><pre><code>constexpr T midpoint() const;\n</code></pre> Returns \\((a + b) / 2\\).</p>"},{"location":"api/interval/#operations","title":"Operations","text":""},{"location":"api/interval/#intersectconst-interval-other","title":"<code>intersect(const interval&amp; other)</code>","text":"<p><pre><code>constexpr interval intersect(const interval&amp; other) const;\n</code></pre> Returns intersection.</p>"},{"location":"api/interval/#hullconst-interval-other","title":"<code>hull(const interval&amp; other)</code>","text":"<p><pre><code>constexpr std::optional&lt;interval&gt; hull(const interval&amp; other) const;\n</code></pre> Returns convex hull if intervals overlap or are adjacent, otherwise <code>std::nullopt</code>.</p>"},{"location":"api/interval/#operators","title":"Operators","text":"<pre><code>// Intersection\nfriend interval operator&amp;(const interval&amp; a, const interval&amp; b);\n\n// Comparison\nfriend auto operator&lt;=&gt;(const interval&amp; a, const interval&amp; b);\nfriend bool operator==(const interval&amp; a, const interval&amp; b);\n\n// Stream output\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const interval&amp; i);\n</code></pre>"},{"location":"api/interval/#complete-example","title":"Complete Example","text":"<p>See Getting Started and Examples for usage examples.</p>"},{"location":"api/multi-dimensional/","title":"Multi-Dimensional Intervals","text":"<p>API for N-dimensional hyperrectangles.</p>"},{"location":"api/multi-dimensional/#interval_ndt-n","title":"<code>interval_nd&lt;T, N&gt;</code>","text":"<pre><code>template&lt;typename T, size_t N&gt;\nclass interval_nd;\n</code></pre>"},{"location":"api/multi-dimensional/#type-aliases","title":"Type Aliases","text":"<pre><code>template&lt;typename T&gt; using rectangle = interval_nd&lt;T, 2&gt;;\ntemplate&lt;typename T&gt; using box = interval_nd&lt;T, 3&gt;;\n</code></pre>"},{"location":"api/multi-dimensional/#example","title":"Example","text":"<pre><code>auto rect = dis::rectangle&lt;double&gt;::closed(0, 10, 0, 5);\nassert(rect.contains({5, 2.5}));\nassert(rect.area() == 50);\n</code></pre>"},{"location":"api/parser-formatter/","title":"Parser &amp; Formatter API","text":"<p>String parsing and formatting for interval sets.</p>"},{"location":"api/parser-formatter/#parser","title":"Parser","text":""},{"location":"api/parser-formatter/#from_stringstdstring_view-str","title":"<code>from_string(std::string_view str)</code>","text":"<p>Parses mathematical notation:</p> <pre><code>auto set = real_set::from_string(\"[0,5) \u222a (10,20] \u222a {25}\");\n</code></pre> <p>Supported Syntax:</p> <ul> <li>Intervals: <code>[a,b]</code>, <code>(a,b)</code>, <code>[a,b)</code>, <code>(a,b]</code></li> <li>Singletons: <code>{x}</code></li> <li>Union: <code>\u222a</code>, <code>U</code>, <code>,</code> (comma)</li> <li>Infinity: <code>\u221e</code>, <code>-\u221e</code></li> </ul>"},{"location":"api/parser-formatter/#formatter","title":"Formatter","text":""},{"location":"api/parser-formatter/#to_string","title":"<code>to_string()</code>","text":"<p>Converts set to string representation:</p> <pre><code>std::string notation = set.to_string();\n</code></pre>"},{"location":"api/parser-formatter/#stream-output","title":"Stream Output","text":"<pre><code>std::cout &lt;&lt; set &lt;&lt; '\\n';  // Uses default formatting\n</code></pre>"},{"location":"api/type-aliases/","title":"Type Aliases","text":"<p>Common type aliases for convenience.</p>"},{"location":"api/type-aliases/#interval-types","title":"Interval Types","text":"<pre><code>namespace dis {\n    using real_interval = interval&lt;double&gt;;\n    using integer_interval = interval&lt;int&gt;;\n}\n</code></pre>"},{"location":"api/type-aliases/#set-types","title":"Set Types","text":"<pre><code>namespace dis {\n    using real_set = disjoint_interval_set&lt;real_interval&gt;;\n    using integer_set = disjoint_interval_set&lt;integer_interval&gt;;\n}\n</code></pre>"},{"location":"api/type-aliases/#multi-dimensional","title":"Multi-Dimensional","text":"<pre><code>namespace dis {\n    template&lt;typename T&gt;\n    using rectangle = interval_nd&lt;T, 2&gt;;\n\n    template&lt;typename T&gt;\n    using box = interval_nd&lt;T, 3&gt;;\n}\n</code></pre>"},{"location":"guide/basic-operations/","title":"Basic Operations Guide","text":"<p>Learn the fundamental operations of DIS.</p>"},{"location":"guide/basic-operations/#creating-intervals","title":"Creating Intervals","text":"<p>See Getting Started for basics.</p>"},{"location":"guide/basic-operations/#set-operations","title":"Set Operations","text":"<p>Full Boolean algebra operations are supported.</p> <p>See Examples for comprehensive usage.</p>"},{"location":"guide/compile-time-intervals/","title":"Compile-Time Intervals Guide","text":"<p>Using static intervals for zero-overhead validation.</p> <p>Coming soon. See Technical Report.</p>"},{"location":"guide/functional-programming/","title":"Functional Programming Guide","text":"<p>Using functional operations like filter, map, and for_each.</p> <p>Coming soon. See API Reference.</p>"},{"location":"guide/set-operations/","title":"Set Operations Guide","text":"<p>Detailed guide to set-theoretic operations.</p> <p>Coming soon. See Examples for now.</p>"},{"location":"guide/string-dsl/","title":"String DSL Guide","text":"<p>Using the mathematical notation parser.</p> <p>Coming soon. See API Reference.</p>"},{"location":"technical-report/applications/","title":"Applications","text":"<p>The DIS library excels in domains requiring interval manipulation and set-theoretic reasoning. This section presents real-world applications across multiple domains.</p>"},{"location":"technical-report/applications/#computational-geometry","title":"Computational Geometry","text":""},{"location":"technical-report/applications/#1d-geometric-operations","title":"1D Geometric Operations","text":"<p>Interval sets naturally represent 1D geometric objects:</p> <pre><code>// Line segment operations\nauto segment1 = real_set{real_interval::closed(0, 10)};\nauto segment2 = real_set{real_interval::closed(5, 15)};\n\nauto overlap = segment1 &amp; segment2;        // [5, 10]\nauto coverage = segment1 | segment2;       // [0, 15]\nauto gap = segment1 ^ segment2;            // [0, 5) \u222a (10, 15]\n</code></pre>"},{"location":"technical-report/applications/#polygon-clipping","title":"Polygon Clipping","text":"<p>Using scanline algorithm with interval sets:</p> <pre><code>std::map&lt;double, real_set&gt; scanlines;  // y-coordinate \u2192 x-intervals\n\n// For each polygon edge, update scanlines\nfor (const auto&amp; edge : polygon.edges()) {\n    double y_start = edge.min_y();\n    double y_end = edge.max_y();\n\n    // Add x-interval at this y-coordinate\n    scanlines[y_start].insert(real_interval::closed(\n        edge.x_at_y(y_start),\n        edge.x_at_y(y_end)\n    ));\n}\n\n// Boolean operations on polygons become set operations on scanlines\nauto clip_polygon = [](const auto&amp; p1, const auto&amp; p2) {\n    std::map&lt;double, real_set&gt; result;\n    for (auto y : all_y_coordinates) {\n        result[y] = p1.scanlines[y] &amp; p2.scanlines[y];\n    }\n    return result;\n};\n</code></pre>"},{"location":"technical-report/applications/#constructive-solid-geometry-csg","title":"Constructive Solid Geometry (CSG)","text":"<p>Build complex shapes via set operations:</p> <pre><code>// 2D example: Create a rounded rectangle\nauto rectangle = real_set::from_string(\"[0,100]\");\nauto left_round = /* circular cutout */;\nauto right_round = /* circular cutout */;\n\nauto rounded_rect = (rectangle - left_round) - right_round;\n\n// 3D example: Create a hollow sphere\nauto outer_sphere = box&lt;double&gt;::sphere(origin, 10.0);\nauto inner_sphere = box&lt;double&gt;::sphere(origin, 9.5);\nauto shell = outer_sphere - inner_sphere;\n</code></pre>"},{"location":"technical-report/applications/#scheduling-and-resource-allocation","title":"Scheduling and Resource Allocation","text":""},{"location":"technical-report/applications/#meeting-room-scheduling","title":"Meeting Room Scheduling","text":"<pre><code>#include &lt;dis/dis.hpp&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nusing namespace dis;\n\nclass RoomScheduler {\n    std::map&lt;std::string, real_set&gt; room_schedules_;\n    real_set business_hours_;\n\npublic:\n    RoomScheduler()\n        : business_hours_(real_set{}\n            .add(9, 12)   // Morning\n            .add(14, 17)) // Afternoon\n    {}\n\n    bool book_meeting(const std::string&amp; room,\n                     double start, double end) {\n        auto meeting = real_interval::closed(start, end);\n\n        // Check if room is available\n        if (!room_schedules_[room].overlaps(real_set{meeting})) {\n            room_schedules_[room].insert(meeting);\n            return true;\n        }\n        return false;\n    }\n\n    real_set find_free_slots(const std::string&amp; room,\n                             double min_duration) const {\n        auto available = business_hours_;\n\n        if (auto it = room_schedules_.find(room);\n            it != room_schedules_.end()) {\n            available = available - it-&gt;second;\n        }\n\n        // Filter slots by minimum duration\n        return available.filter([min_duration](const auto&amp; slot) {\n            return slot.length() &gt;= min_duration;\n        });\n    }\n\n    std::vector&lt;std::string&gt; find_rooms_available(double start, double end) const {\n        auto required = real_interval::closed(start, end);\n        std::vector&lt;std::string&gt; available_rooms;\n\n        for (const auto&amp; [room, schedule] : room_schedules_) {\n            if (!schedule.overlaps(real_set{required})) {\n                available_rooms.push_back(room);\n            }\n        }\n\n        return available_rooms;\n    }\n\n    double utilization(const std::string&amp; room) const {\n        if (auto it = room_schedules_.find(room);\n            it != room_schedules_.end()) {\n            return it-&gt;second.measure() / business_hours_.measure();\n        }\n        return 0.0;\n    }\n};\n\n// Usage\nRoomScheduler scheduler;\nscheduler.book_meeting(\"Room A\", 10, 11);\nscheduler.book_meeting(\"Room A\", 15, 16);\n\nauto free_slots = scheduler.find_free_slots(\"Room A\", 1.0);\nstd::cout &lt;&lt; \"Free slots (\u22651 hour): \" &lt;&lt; free_slots &lt;&lt; '\\n';\n// Output: [9,10) \u222a (11,12] \u222a [14,15) \u222a (16,17]\n</code></pre>"},{"location":"technical-report/applications/#cpugpu-resource-allocation","title":"CPU/GPU Resource Allocation","text":"<pre><code>class ResourceAllocator {\n    real_set allocated_time_;\n\npublic:\n    bool can_allocate(double start, double duration) const {\n        auto request = real_interval::closed(start, start + duration);\n        return !allocated_time_.overlaps(real_set{request});\n    }\n\n    void allocate(double start, double duration) {\n        allocated_time_.insert(\n            real_interval::closed(start, start + duration)\n        );\n    }\n\n    real_set find_next_available(double min_duration) const {\n        auto free = ~allocated_time_;  // Complement\n        return free.filter([min_duration](const auto&amp; slot) {\n            return slot.length() &gt;= min_duration;\n        });\n    }\n};\n</code></pre>"},{"location":"technical-report/applications/#numerical-analysis","title":"Numerical Analysis","text":""},{"location":"technical-report/applications/#interval-arithmetic-for-error-bounds","title":"Interval Arithmetic for Error Bounds","text":"<pre><code>class UncertainValue {\n    real_set possible_values_;\n\npublic:\n    UncertainValue(double center, double uncertainty)\n        : possible_values_(real_set{\n            real_interval::closed(center - uncertainty,\n                                 center + uncertainty)\n        }) {}\n\n    UncertainValue(real_set values)\n        : possible_values_(std::move(values)) {}\n\n    UncertainValue operator+(const UncertainValue&amp; other) const {\n        real_set result;\n        for (const auto&amp; i1 : possible_values_) {\n            for (const auto&amp; i2 : other.possible_values_) {\n                double min = *i1.lower_bound() + *i2.lower_bound();\n                double max = *i1.upper_bound() + *i2.upper_bound();\n                result.insert(real_interval::closed(min, max));\n            }\n        }\n        return UncertainValue(std::move(result));\n    }\n\n    UncertainValue operator*(const UncertainValue&amp; other) const {\n        real_set result;\n        for (const auto&amp; i1 : possible_values_) {\n            for (const auto&amp; i2 : other.possible_values_) {\n                auto products = std::array{\n                    *i1.lower_bound() * *i2.lower_bound(),\n                    *i1.lower_bound() * *i2.upper_bound(),\n                    *i1.upper_bound() * *i2.lower_bound(),\n                    *i1.upper_bound() * *i2.upper_bound()\n                };\n                auto [min, max] = std::minmax_element(\n                    products.begin(), products.end()\n                );\n                result.insert(real_interval::closed(*min, *max));\n            }\n        }\n        return UncertainValue(std::move(result));\n    }\n\n    real_interval bounds() const {\n        return possible_values_.span();\n    }\n\n    double uncertainty() const {\n        auto span = possible_values_.span();\n        return span.length() / 2.0;\n    }\n};\n\n// Usage: Propagate measurement uncertainty\nUncertainValue voltage(5.0, 0.1);    // 5V \u00b1 0.1V\nUncertainValue current(2.0, 0.05);   // 2A \u00b1 0.05A\nauto power = voltage * current;      // ~10W with propagated uncertainty\n\nstd::cout &lt;&lt; \"Power: \" &lt;&lt; power.bounds() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Uncertainty: \u00b1\" &lt;&lt; power.uncertainty() &lt;&lt; \"W\\n\";\n</code></pre>"},{"location":"technical-report/applications/#range-analysis-in-program-verification","title":"Range Analysis in Program Verification","text":"<pre><code>// Track possible values of variables during symbolic execution\nstd::map&lt;std::string, real_set&gt; variable_ranges;\n\n// After: x = [5, 10]; y = [0, 3];\nvariable_ranges[\"x\"] = real_set::from_string(\"[5,10]\");\nvariable_ranges[\"y\"] = real_set::from_string(\"[0,3]\");\n\n// Analyze: z = x + y\nauto z_range = /* compute from x and y ranges */;\nvariable_ranges[\"z\"] = z_range;  // [5, 13]\n\n// Check assertion: assert(z &gt; 0)\nbool assertion_holds = !z_range.overlaps(\n    real_set{real_interval::at_most(0)}\n);\n</code></pre>"},{"location":"technical-report/applications/#access-control","title":"Access Control","text":""},{"location":"technical-report/applications/#time-based-access-control","title":"Time-Based Access Control","text":"<pre><code>class AccessPolicy {\n    real_set allowed_hours_;\n    std::set&lt;std::string&gt; allowed_users_;\n\npublic:\n    AccessPolicy()\n        : allowed_hours_(real_set{}\n            .add(9, 17)  // Business hours\n            .remove(real_interval::closed(12, 13))  // Lunch break\n        ) {}\n\n    bool can_access(const std::string&amp; user, double time) const {\n        return allowed_users_.contains(user) &amp;&amp;\n               allowed_hours_.contains(time);\n    }\n\n    real_set get_access_windows(const std::string&amp; user) const {\n        if (allowed_users_.contains(user)) {\n            return allowed_hours_;\n        }\n        return real_set::empty();\n    }\n\n    void add_exception(double start, double end) {\n        // Add special access window (e.g., maintenance)\n        allowed_hours_.insert(real_interval::closed(start, end));\n    }\n};\n</code></pre>"},{"location":"technical-report/applications/#ip-address-range-management","title":"IP Address Range Management","text":"<pre><code>// IPv4 addresses as 32-bit integers\nusing ip_set = disjoint_interval_set&lt;interval&lt;uint32_t&gt;&gt;;\n\nclass FirewallRules {\n    ip_set allowed_ips_;\n    ip_set blocked_ips_;\n\npublic:\n    void allow_range(uint32_t start, uint32_t end) {\n        allowed_ips_.insert(integer_interval::closed(start, end));\n    }\n\n    void block_range(uint32_t start, uint32_t end) {\n        blocked_ips_.insert(integer_interval::closed(start, end));\n    }\n\n    bool is_allowed(uint32_t ip) const {\n        return allowed_ips_.contains(ip) &amp;&amp;\n               !blocked_ips_.contains(ip);\n    }\n\n    // Get effective allowed IPs (allowed - blocked)\n    ip_set effective_allowed() const {\n        return allowed_ips_ - blocked_ips_;\n    }\n};\n\n// Usage\nFirewallRules fw;\nfw.allow_range(ip_to_uint(\"10.0.0.0\"), ip_to_uint(\"10.255.255.255\"));\nfw.block_range(ip_to_uint(\"10.0.1.0\"), ip_to_uint(\"10.0.1.255\"));\n\nif (fw.is_allowed(ip_to_uint(\"10.0.2.5\"))) {\n    // Allow connection\n}\n</code></pre>"},{"location":"technical-report/applications/#data-analysis-and-visualization","title":"Data Analysis and Visualization","text":""},{"location":"technical-report/applications/#histogram-binning","title":"Histogram Binning","text":"<pre><code>class Histogram {\n    std::map&lt;real_interval, size_t&gt; bins_;\n\npublic:\n    void add_bin(double start, double end) {\n        bins_[real_interval::closed(start, end)] = 0;\n    }\n\n    void add_value(double value) {\n        for (auto&amp; [interval, count] : bins_) {\n            if (interval.contains(value)) {\n                ++count;\n                break;\n            }\n        }\n    }\n\n    void print() const {\n        for (const auto&amp; [interval, count] : bins_) {\n            std::cout &lt;&lt; interval &lt;&lt; \": \"\n                     &lt;&lt; std::string(count, '*') &lt;&lt; '\\n';\n        }\n    }\n};\n</code></pre>"},{"location":"technical-report/applications/#range-query-optimization","title":"Range Query Optimization","text":"<pre><code>class TimeSeriesIndex {\n    std::map&lt;real_interval, std::vector&lt;DataPoint&gt;&gt; index_;\n\npublic:\n    void index_data(const std::vector&lt;DataPoint&gt;&amp; data) {\n        // Partition data into intervals\n        for (const auto&amp; point : data) {\n            auto interval = real_interval::closed(\n                std::floor(point.timestamp),\n                std::ceil(point.timestamp)\n            );\n            index_[interval].push_back(point);\n        }\n    }\n\n    std::vector&lt;DataPoint&gt; query_range(double start, double end) {\n        auto query = real_interval::closed(start, end);\n        std::vector&lt;DataPoint&gt; results;\n\n        for (const auto&amp; [interval, points] : index_) {\n            if (interval.overlaps(query)) {\n                // Filter points within exact range\n                for (const auto&amp; point : points) {\n                    if (query.contains(point.timestamp)) {\n                        results.push_back(point);\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n};\n</code></pre>"},{"location":"technical-report/applications/#signal-processing","title":"Signal Processing","text":""},{"location":"technical-report/applications/#frequency-band-allocation","title":"Frequency Band Allocation","text":"<pre><code>class SpectrumManager {\n    real_set allocated_bands_;\n    const double min_freq = 0.0;\n    const double max_freq = 6000.0;  // MHz\n\npublic:\n    bool allocate_band(double start, double end) {\n        auto band = real_interval::closed(start, end);\n\n        if (!allocated_bands_.overlaps(real_set{band})) {\n            allocated_bands_.insert(band);\n            return true;\n        }\n        return false;\n    }\n\n    real_set find_available_bands(double bandwidth) const {\n        auto available = real_set{real_interval::closed(min_freq, max_freq)}\n                        - allocated_bands_;\n\n        return available.filter([bandwidth](const auto&amp; band) {\n            return band.length() &gt;= bandwidth;\n        });\n    }\n\n    double spectrum_efficiency() const {\n        return allocated_bands_.measure() / (max_freq - min_freq);\n    }\n};\n\n// Usage: Allocate WiFi channels\nSpectrumManager wifi;\nwifi.allocate_band(2412, 2437);  // Channel 1-6\nwifi.allocate_band(5180, 5320);  // 5GHz band\n\nauto available = wifi.find_available_bands(20);  // Need 20MHz\n</code></pre>"},{"location":"technical-report/applications/#game-development","title":"Game Development","text":""},{"location":"technical-report/applications/#collision-detection-1d","title":"Collision Detection (1D)","text":"<pre><code>// Simple platformer collision detection\nstruct Entity {\n    real_interval x_bounds;\n    real_interval y_bounds;\n\n    bool collides_with(const Entity&amp; other) const {\n        return x_bounds.overlaps(other.x_bounds) &amp;&amp;\n               y_bounds.overlaps(other.y_bounds);\n    }\n};\n\n// Level editor: Track occupied space\nclass LevelEditor {\n    disjoint_interval_set&lt;real_interval&gt; occupied_x_;\n    disjoint_interval_set&lt;real_interval&gt; occupied_y_;\n\npublic:\n    bool can_place(double x, double y, double width, double height) {\n        auto x_range = real_interval::closed(x, x + width);\n        auto y_range = real_interval::closed(y, y + height);\n\n        return !occupied_x_.overlaps(real_set{x_range}) &amp;&amp;\n               !occupied_y_.overlaps(real_set{y_range});\n    }\n\n    void place(double x, double y, double width, double height) {\n        occupied_x_.insert(real_interval::closed(x, x + width));\n        occupied_y_.insert(real_interval::closed(y, y + height));\n    }\n};\n</code></pre>"},{"location":"technical-report/applications/#summary","title":"Summary","text":"<p>The DIS library's mathematical foundation and elegant API make it suitable for:</p> <ul> <li>Geometric algorithms: CSG, clipping, intersection testing</li> <li>Resource management: Scheduling, allocation, conflict detection</li> <li>Numerical methods: Error bounds, range analysis, uncertainty propagation</li> <li>Security systems: Access control, IP filtering, time-based permissions</li> <li>Data analysis: Binning, range queries, aggregation</li> <li>Signal processing: Spectrum management, band allocation</li> <li>Game development: Collision detection, spatial indexing</li> </ul> <p>The common thread: problems naturally expressible as set operations on intervals benefit from DIS's mathematical rigor and ergonomic API.</p>"},{"location":"technical-report/design-implementation/","title":"Design &amp; Implementation","text":"<p>This section describes the design philosophy and implementation techniques used in the DIS library. We emphasize API ergonomics, zero-cost abstractions, and compositional design.</p>"},{"location":"technical-report/design-implementation/#core-abstraction-the-interval-class","title":"Core Abstraction: The Interval Class","text":""},{"location":"technical-report/design-implementation/#interface-design","title":"Interface Design","text":"<p>The <code>interval&lt;T&gt;</code> template provides the fundamental interval abstraction:</p> <pre><code>template&lt;Boundary T&gt;\nclass interval {\npublic:\n    using value_type = T;\n\n    // === Named Constructors (Factory Methods) ===\n\n    [[nodiscard]] static constexpr interval closed(T lower, T upper);\n    [[nodiscard]] static constexpr interval open(T lower, T upper);\n    [[nodiscard]] static constexpr interval left_open(T lower, T upper);\n    [[nodiscard]] static constexpr interval right_open(T lower, T upper);\n    [[nodiscard]] static constexpr interval point(T value);\n    [[nodiscard]] static constexpr interval empty();\n\n    // Unbounded intervals (requires infinity support)\n    [[nodiscard]] static constexpr interval unbounded();\n    [[nodiscard]] static constexpr interval at_least(T lower);\n    [[nodiscard]] static constexpr interval at_most(T upper);\n    [[nodiscard]] static constexpr interval greater_than(T lower);\n    [[nodiscard]] static constexpr interval less_than(T upper);\n\n    // === Core Operations ===\n\n    constexpr bool contains(T value) const;\n    constexpr bool overlaps(const interval&amp; other) const;\n    constexpr interval intersect(const interval&amp; other) const;\n    constexpr std::optional&lt;interval&gt; hull(const interval&amp; other) const;\n\n    // === Queries ===\n\n    constexpr bool is_empty() const;\n    constexpr std::optional&lt;T&gt; lower_bound() const;\n    constexpr std::optional&lt;T&gt; upper_bound() const;\n    constexpr T length() const requires std::is_arithmetic_v&lt;T&gt;;\n    constexpr T midpoint() const requires std::is_arithmetic_v&lt;T&gt;;\n};\n</code></pre>"},{"location":"technical-report/design-implementation/#design-rationale","title":"Design Rationale","text":"<p>Named Constructors: Instead of:</p> <pre><code>interval(0, 10, true, false);  // What does this mean?\n</code></pre> <p>We provide:</p> <pre><code>interval::right_open(0, 10);   // Clear intent!\n</code></pre> <p>This eliminates cognitive overhead and reduces errors.</p> <p>Const by Default: All operations return new intervals rather than modifying in-place, supporting functional programming style and enabling thread safety.</p> <p>Constexpr Everything: All operations are <code>constexpr</code>, enabling compile-time computation:</p> <pre><code>constexpr auto i = real_interval::closed(0, 10);\nstatic_assert(i.contains(5));  // Verified at compile-time\n</code></pre> <p>Requires Clauses: C++20 <code>requires</code> clauses provide clear compile-time constraints:</p> <pre><code>constexpr T length() const requires std::is_arithmetic_v&lt;T&gt;;\n</code></pre> <p>This generates better error messages when misused.</p>"},{"location":"technical-report/design-implementation/#disjoint-interval-set-class","title":"Disjoint Interval Set Class","text":""},{"location":"technical-report/design-implementation/#core-implementation","title":"Core Implementation","text":"<pre><code>template&lt;typename I&gt;\nclass disjoint_interval_set {\n    std::vector&lt;I&gt; intervals_;  // Sorted, disjoint, non-adjacent\n\n    // Maintains canonical form\n    void normalize() {\n        if (intervals_.empty()) return;\n\n        // Sort by lower bounds\n        std::ranges::sort(intervals_, [](const I&amp; a, const I&amp; b) {\n            return *a.lower_bound() &lt; *b.lower_bound();\n        });\n\n        // Merge overlapping/adjacent intervals\n        size_t write = 0;\n        for (size_t read = 1; read &lt; intervals_.size(); ++read) {\n            if (auto merged = intervals_[write].hull(intervals_[read])) {\n                intervals_[write] = *merged;\n            } else {\n                intervals_[++write] = intervals_[read];\n            }\n        }\n        intervals_.resize(write + 1);\n    }\n\npublic:\n    // Multiple API styles...\n};\n</code></pre>"},{"location":"technical-report/design-implementation/#the-normalization-algorithm","title":"The Normalization Algorithm","text":"<p>The <code>normalize()</code> method is central to maintaining canonical form:</p> <ol> <li>Sort: Order intervals by lower bound (O(n log n))</li> <li>Merge: Single-pass merge of overlapping/adjacent intervals (O(n))</li> </ol> <p>The key insight: <code>hull()</code> returns <code>std::optional&lt;interval&gt;</code>, succeeding only for overlapping or adjacent intervals. This elegantly handles both cases.</p> <p>Example:</p> <pre><code>// Input: [(5,10), [2,4], (3,6], [10,15]]\n// After sort: [[2,4], (3,6], (5,10), [10,15]]\n// After merge: [[2,10), [10,15]]  // Adjacent intervals merged\n// Final: [[2,15]]                  // All intervals merged\n</code></pre>"},{"location":"technical-report/design-implementation/#api-design-philosophy","title":"API Design Philosophy","text":""},{"location":"technical-report/design-implementation/#multiple-equivalent-notations","title":"Multiple Equivalent Notations","text":"<p>We provide three ways to express the same operations:</p>"},{"location":"technical-report/design-implementation/#1-mathematical-operators-concise","title":"1. Mathematical Operators (Concise)","text":"<pre><code>auto result = (a | b) &amp; ~c;  // (A \u222a B) \u2229 \u00acC\n</code></pre> <p>When to use: Complex expressions, symbolic manipulation, mathematical contexts.</p>"},{"location":"technical-report/design-implementation/#2-named-methods-explicit","title":"2. Named Methods (Explicit)","text":"<pre><code>auto result = a.unite(b).intersect(c.complement());\n</code></pre> <p>When to use: Self-documenting code, unfamiliar teams, API discovery.</p>"},{"location":"technical-report/design-implementation/#3-fluent-interface-chainable","title":"3. Fluent Interface (Chainable)","text":"<pre><code>auto result = real_set{}\n    .add(0, 10)\n    .add(20, 30)\n    .remove(real_interval::closed(5, 25));\n</code></pre> <p>When to use: Building complex sets step-by-step, imperative style.</p>"},{"location":"technical-report/design-implementation/#operator-overloading","title":"Operator Overloading","text":"<p>We carefully chose operators to match mathematical convention:</p> Operation Operator Method Mathematical Union <code>a \\| b</code> <code>a.unite(b)</code> \\(A \\cup B\\) Intersection <code>a &amp; b</code> <code>a.intersect(b)</code> \\(A \\cap B\\) Complement <code>~a</code> <code>a.complement()</code> \\(\\neg A\\) Difference <code>a - b</code> <code>a.difference(b)</code> \\(A \\setminus B\\) Symmetric Diff <code>a ^ b</code> <code>a.symmetric_difference(b)</code> \\(A \\triangle B\\) <p>Precedence: C++ operator precedence matches mathematical convention for these operations.</p>"},{"location":"technical-report/design-implementation/#compile-time-intervals","title":"Compile-Time Intervals","text":""},{"location":"technical-report/design-implementation/#static-interval-template","title":"Static Interval Template","text":"<p>For compile-time validation:</p> <pre><code>template&lt;auto Min, auto Max, bool LeftClosed, bool RightClosed&gt;\nstruct static_interval {\n    static constexpr auto min = Min;\n    static constexpr auto max = Max;\n    static constexpr bool left_closed = LeftClosed;\n    static constexpr bool right_closed = RightClosed;\n\n    static constexpr bool contains(auto value) {\n        const bool left_ok = LeftClosed ? (value &gt;= min) : (value &gt; min);\n        const bool right_ok = RightClosed ? (value &lt;= max) : (value &lt; max);\n        return left_ok &amp;&amp; right_ok;\n    }\n\n    static constexpr auto length() { return max - min; }\n};\n</code></pre>"},{"location":"technical-report/design-implementation/#application-bounded-types","title":"Application: Bounded Types","text":"<pre><code>template&lt;int Min, int Max&gt;\nclass percentage {\n    using bounds = static_interval&lt;Min, Max, true, true&gt;;\n    int value_;\n\npublic:\n    constexpr percentage(int v) : value_(v) {\n        if (!bounds::contains(v))\n            throw std::out_of_range(\"Value out of bounds\");\n    }\n\n    constexpr operator int() const { return value_; }\n};\n\nusing percent = percentage&lt;0, 100&gt;;\n\n// Compile-time verification\nstatic_assert(percent::bounds::contains(50));\nstatic_assert(!percent::bounds::contains(150));\n\n// Runtime validation\npercent p1(75);   // OK\npercent p2(150);  // Throws exception\n</code></pre> <p>This achieves zero runtime overhead for valid inputs in optimized builds.</p>"},{"location":"technical-report/design-implementation/#domain-specific-language","title":"Domain-Specific Language","text":""},{"location":"technical-report/design-implementation/#parser-design","title":"Parser Design","text":"<p>The parser supports standard mathematical notation:</p> <pre><code>// Supported syntax:\n\"[0,10]\"              // Closed interval\n\"(0,10)\"              // Open interval\n\"[0,10)\"              // Right-open interval\n\"{5}\"                 // Singleton\n\"[0,5) \u222a (10,20]\"     // Union with Unicode\n\"[0,5) U (10,20]\"     // Union with ASCII\n\"[0,5), (10,20]\"      // Comma-separated union\n\"[0,\u221e)\"               // Unbounded\n\"(-\u221e,0]\"              // Unbounded\n</code></pre>"},{"location":"technical-report/design-implementation/#implementation","title":"Implementation","text":"<p>Recursive descent parser with these production rules:</p> <pre><code>expression := term (union_op term)*\nterm       := interval | singleton | empty\ninterval   := '[' number ',' number ']'\n            | '(' number ',' number ')'\n            | '[' number ',' number ')'\n            | '(' number ',' number ']'\nsingleton  := '{' number '}'\nempty      := '{' '}'\nunion_op   := '\u222a' | 'U' | ','\nnumber     := digit+ ('.' digit+)? | '\u221e' | '-\u221e'\n</code></pre> <p>Round-Trip Property: <code>from_string(to_string(s)) == s</code> for all valid sets.</p>"},{"location":"technical-report/design-implementation/#multi-dimensional-extension","title":"Multi-Dimensional Extension","text":""},{"location":"technical-report/design-implementation/#hyperrectangles","title":"Hyperrectangles","text":"<p>Intervals generalize naturally to N dimensions:</p> <pre><code>template&lt;typename T, size_t N&gt;\nclass interval_nd {\n    std::array&lt;interval&lt;T&gt;, N&gt; axes_;\n\npublic:\n    bool contains(const std::array&lt;T, N&gt;&amp; point) const {\n        for (size_t i = 0; i &lt; N; ++i) {\n            if (!axes_[i].contains(point[i]))\n                return false;\n        }\n        return true;\n    }\n\n    T measure() const {\n        T result = 1;\n        for (const auto&amp; axis : axes_) {\n            result *= axis.length();\n        }\n        return result;\n    }\n\n    interval_nd intersect(const interval_nd&amp; other) const {\n        interval_nd result;\n        for (size_t i = 0; i &lt; N; ++i) {\n            result.axes_[i] = axes_[i].intersect(other.axes_[i]);\n        }\n        return result;\n    }\n};\n\n// Convenient aliases\ntemplate&lt;typename T&gt; using rectangle = interval_nd&lt;T, 2&gt;;\ntemplate&lt;typename T&gt; using box = interval_nd&lt;T, 3&gt;;\n</code></pre>"},{"location":"technical-report/design-implementation/#applications","title":"Applications","text":"<p>2D Spatial Queries:</p> <pre><code>auto screen = rectangle&lt;int&gt;::closed(0, 1920, 0, 1080);\nauto window = rectangle&lt;int&gt;::closed(100, 500, 100, 400);\n\nassert(screen.contains(window));\nassert(window.area() == 120000);\n</code></pre> <p>3D Collision Detection:</p> <pre><code>auto room = box&lt;double&gt;::closed(0, 10, 0, 10, 0, 3);\nauto furniture = box&lt;double&gt;::closed(2, 4, 3, 5, 0, 1);\n\nbool fits = room.contains(furniture);\ndouble volume = furniture.volume();\n</code></pre>"},{"location":"technical-report/design-implementation/#memory-layout-and-optimization","title":"Memory Layout and Optimization","text":""},{"location":"technical-report/design-implementation/#interval-storage","title":"Interval Storage","text":"<p>Each <code>interval&lt;T&gt;</code> contains:</p> <pre><code>T lower_;            // sizeof(T)\nT upper_;            // sizeof(T)\nbool left_closed_;   // 1 byte (could pack into padding)\nbool right_closed_;  // 1 byte (could pack into padding)\n</code></pre> <p>For <code>real_interval</code> (T=double): 16 + 2 = 18 bytes, typically padded to 24 bytes.</p>"},{"location":"technical-report/design-implementation/#set-storage","title":"Set Storage","text":"<p><code>disjoint_interval_set</code> uses <code>std::vector&lt;I&gt;</code>:</p> <ul> <li>Small sets: Direct storage, no heap allocation for capacity \u2264 N (small vector optimization in some STL implementations)</li> <li>Large sets: Heap allocation, exponential growth strategy</li> <li>Move semantics: Efficient transfers without copying</li> </ul>"},{"location":"technical-report/design-implementation/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li> <p>Reserve: Pre-allocate capacity when size is known    <pre><code>real_set s;\ns.reserve(100);  // Avoid reallocation\n</code></pre></p> </li> <li> <p>Move construction: Avoid copies    <pre><code>auto s = real_set{}.add(1,2).add(3,4);  // No copies\n</code></pre></p> </li> <li> <p>Binary search: O(log n) contains queries</p> </li> <li>Single-pass normalization: O(n) after construction</li> </ol>"},{"location":"technical-report/design-implementation/#summary","title":"Summary","text":"<p>The DIS library demonstrates how careful API design can make complex mathematical concepts both accessible and efficient:</p> <ul> <li>Multiple notations respect different coding styles</li> <li>Named constructors improve readability</li> <li>Compile-time features provide zero-cost abstractions</li> <li>Canonical form enables efficient algorithms</li> <li>Value semantics support functional programming</li> </ul> <p>The result is a library that is simultaneously mathematically rigorous, ergonomically pleasant, and computationally efficient.</p>"},{"location":"technical-report/introduction/","title":"Introduction","text":"<p>Intervals are fundamental mathematical objects appearing throughout computer science: from computational geometry algorithms to scheduling systems, from numerical analysis to access control mechanisms. While several interval libraries exist\u2014notably Boost.ICL (Interval Container Library)\u2014most treat intervals as containers requiring explicit management of overlaps and adjacency. This approach places burden on the programmer and obscures the underlying mathematical structure.</p> <p>We present a different philosophy: treating interval sets as first-class mathematical objects that form a complete Boolean algebra. This perspective leads naturally to intuitive operations, compositional design, and strong correctness guarantees. Our key insight is that by maintaining a canonical form (disjoint, sorted intervals), we can provide both mathematical elegance and computational efficiency.</p>"},{"location":"technical-report/introduction/#motivation","title":"Motivation","text":"<p>Consider a simple scheduling problem: finding free time in a calendar. Traditional approaches require manual loop over intervals, explicit overlap checking, and careful boundary handling. With DIS, the solution is natural:</p> <pre><code>auto availability = real_set{}.add(9, 17);  // 9 AM - 5 PM\nauto meetings = real_set::from_string(\"[10,11] \u222a [14,15]\");\nauto free_time = availability - meetings;   // Set difference\n</code></pre> <p>This code: - Reads like mathematics: The operations mirror set-theoretic notation - Handles all edge cases: Boundaries, overlaps, adjacency handled automatically - Provides guarantees: Result is always in canonical form - Is efficient: O(n + m) complexity for n and m intervals</p>"},{"location":"technical-report/introduction/#contributions","title":"Contributions","text":"<p>This technical report presents:</p> <ol> <li> <p>Complete Boolean Algebra Implementation    Full support for set-theoretic operations (union, intersection, complement, difference, symmetric difference) satisfying all Boolean algebra axioms with formal correctness properties.</p> </li> <li> <p>Elegant API Design    Multiple equivalent notations (operators, named methods, fluent interface) enabling natural expression for different contexts and coding styles.</p> </li> <li> <p>Compile-Time Features    Zero-overhead interval validation and computation using template metaprogramming. Static intervals enable bounded types with compile-time checks.</p> </li> <li> <p>Domain-Specific Language    Parser for standard mathematical notation supporting round-trip serialization: <code>\"[0,5) \u222a (10,20] \u222a {25}\"</code>.</p> </li> <li> <p>Multi-Dimensional Extension    Natural generalization to N-dimensional hyperrectangles for spatial and spatio-temporal applications.</p> </li> <li> <p>Rich Query Interface    Comprehensive operations including <code>gaps()</code>, <code>span()</code>, <code>density()</code>, and <code>measure()</code> for interval analysis.</p> </li> </ol>"},{"location":"technical-report/introduction/#comparison-with-boosticl","title":"Comparison with Boost.ICL","text":"<p>Boost.ICL provides comprehensive interval container functionality but adopts a container-centric design philosophy. Our library differs fundamentally:</p> Aspect DIS Boost.ICL Philosophy Mathematical Boolean algebra Container semantics API Style Natural operators (<code>\\|</code>, <code>&amp;</code>, <code>~</code>) Method calls String Parsing Built-in DSL Not available Dependencies Zero Requires Boost Compile-Time First-class support Limited Multi-Dimensional Native support Requires extension Learning Curve Intuitive for mathematical users Steeper"},{"location":"technical-report/introduction/#design-goals","title":"Design Goals","text":"<p>The library is designed around three core principles:</p>"},{"location":"technical-report/introduction/#1-mathematical-rigor","title":"1. Mathematical Rigor","text":"<p>All operations maintain Boolean algebra properties. The implementation satisfies associativity, commutativity, distributivity, De Morgan's laws, and complement properties. This mathematical foundation provides strong correctness guarantees.</p>"},{"location":"technical-report/introduction/#2-ergonomic-api","title":"2. Ergonomic API","text":"<p>We provide three equivalent ways to express operations:</p> <pre><code>// Symbolic operators (concise)\nauto result = (a | b) &amp; ~c;\n\n// Named methods (self-documenting)\nauto result = a.unite(b).intersect(c.complement());\n\n// Fluent interface (chainable)\nauto result = real_set{}\n    .add(interval1)\n    .add(interval2)\n    .remove(interval3);\n</code></pre> <p>Each style is optimal for different contexts, respecting various coding preferences.</p>"},{"location":"technical-report/introduction/#3-performance","title":"3. Performance","text":"<p>Despite the mathematical abstraction, DIS achieves excellent performance:</p> <ul> <li>O(log n) membership queries via binary search</li> <li>O(n + m) set operations via linear merge</li> <li>Zero runtime overhead for compile-time intervals</li> <li>Automatic normalization maintains canonical form efficiently</li> </ul>"},{"location":"technical-report/introduction/#structure-of-this-report","title":"Structure of This Report","text":"<p>The remainder of this report is organized as follows:</p> <ul> <li>Mathematical Foundation: Formal definitions, Boolean algebra properties, and complexity analysis</li> <li>Design &amp; Implementation: API design philosophy, core algorithms, and implementation techniques</li> <li>Performance Analysis: Complexity analysis, benchmarks, and optimization strategies</li> <li>Applications: Real-world use cases across multiple domains</li> <li>Related Work: Comparison with existing interval libraries and theoretical foundations</li> </ul>"},{"location":"technical-report/introduction/#implementation-status","title":"Implementation Status","text":"<p>The library is production-ready with:</p> <ul> <li>97.46% test coverage on core implementation</li> <li>90.32% overall test coverage</li> <li>94 test cases covering edge cases and real-world scenarios</li> <li>Zero dependencies beyond C++17 standard library</li> <li>Header-only for easy integration</li> </ul> <p>The complete source code is available under the MIT license.</p>"},{"location":"technical-report/mathematical-foundation/","title":"Mathematical Foundation","text":"<p>This section establishes the mathematical theory underlying the Disjoint Interval Set library. We define intervals formally, establish their Boolean algebra structure, and analyze the complexity properties of our canonical representation.</p>"},{"location":"technical-report/mathematical-foundation/#intervals","title":"Intervals","text":""},{"location":"technical-report/mathematical-foundation/#definition","title":"Definition","text":"<p>An interval over a totally ordered set \\((T, \\leq)\\) is defined by its endpoints and boundary types:</p> \\[I = [a, b] \\cup \\{(\\cdot,\\cdot), [\\cdot,\\cdot), (\\cdot,\\cdot], [\\cdot,\\cdot]\\}\\] <p>where \\(a \\leq b\\) are the lower and upper bounds, and boundary indicators specify whether endpoints are included (closed) or excluded (open).</p>"},{"location":"technical-report/mathematical-foundation/#boundary-types","title":"Boundary Types","text":"<p>The four boundary configurations are:</p> <ul> <li>Closed: \\([a, b]\\) includes both endpoints</li> <li>Open: \\((a, b)\\) excludes both endpoints</li> <li>Left-open: \\((a, b]\\) excludes left, includes right</li> <li>Right-open: \\([a, b)\\) includes left, excludes right</li> </ul>"},{"location":"technical-report/mathematical-foundation/#membership","title":"Membership","text":"<p>Point membership is defined as:</p> \\[x \\in [a,b] \\iff a \\leq x \\leq b\\] \\[x \\in (a,b) \\iff a &lt; x &lt; b\\] \\[x \\in (a,b] \\iff a &lt; x \\leq b\\] \\[x \\in [a,b) \\iff a \\leq x &lt; b\\]"},{"location":"technical-report/mathematical-foundation/#empty-intervals","title":"Empty Intervals","text":"<p>An interval is empty if:</p> <ol> <li>\\(a &gt; b\\), or</li> <li>\\(a = b\\) and at least one boundary is open</li> </ol> <p>Empty intervals are represented canonically as \\((0, -1)\\) with both boundaries open, regardless of how they were constructed. This ensures unique representation.</p>"},{"location":"technical-report/mathematical-foundation/#special-intervals","title":"Special Intervals","text":"<p>For types supporting infinity (e.g., <code>double</code>):</p> <ul> <li>Unbounded: \\((-\\infty, \\infty)\\) contains all values</li> <li>Half-bounded: \\([a, \\infty)\\), \\((a, \\infty)\\), \\((-\\infty, b]\\), \\((-\\infty, b)\\)</li> <li>Singleton: \\([a, a]\\) contains exactly one point</li> </ul>"},{"location":"technical-report/mathematical-foundation/#disjoint-interval-sets","title":"Disjoint Interval Sets","text":""},{"location":"technical-report/mathematical-foundation/#definition_1","title":"Definition","text":"<p>A disjoint interval set is a finite collection of pairwise disjoint intervals:</p> \\[D = \\{I_1, I_2, \\ldots, I_n\\} \\quad \\text{where} \\quad I_i \\cap I_j = \\emptyset \\text{ for } i \\neq j\\]"},{"location":"technical-report/mathematical-foundation/#canonical-form","title":"Canonical Form","text":"<p>We maintain intervals in sorted order by lower bounds:</p> \\[I_1 &lt; I_2 &lt; \\cdots &lt; I_n\\] <p>where \\(I &lt; J\\) means the upper bound of \\(I\\) is less than the lower bound of \\(J\\), accounting for boundary types.</p>"},{"location":"technical-report/mathematical-foundation/#adjacency","title":"Adjacency","text":"<p>Two intervals are adjacent if they share a boundary point with opposite closure properties:</p> <ul> <li>\\((a,b]\\) and \\((b,c)\\) are adjacent at \\(b\\)</li> <li>\\([a,b)\\) and \\([b,c]\\) are adjacent at \\(b\\)</li> </ul> <p>Adjacent intervals can be merged into a single interval:</p> <ul> <li>\\((a,b] \\cup (b,c) = (a,c)\\)</li> <li>\\([a,b) \\cup [b,c] = [a,c]\\)</li> </ul> <p>The canonical form merges all adjacent intervals, ensuring unique representation.</p>"},{"location":"technical-report/mathematical-foundation/#boolean-algebra-structure","title":"Boolean Algebra Structure","text":""},{"location":"technical-report/mathematical-foundation/#definition_2","title":"Definition","text":"<p>The set of all disjoint interval sets \\(\\mathcal{D}\\) forms a complete Boolean algebra:</p> \\[(\\mathcal{D}, \\cup, \\cap, \\neg, \\emptyset, U)\\] <p>where:</p> <ul> <li>Join (\\(\\vee\\)): Set union \\(\\cup\\)</li> <li>Meet (\\(\\wedge\\)): Set intersection \\(\\cap\\)</li> <li>Complement (\\(\\neg\\)): Relative to universal set \\(U = (-\\infty, \\infty)\\)</li> <li>Bottom: Empty set \\(\\emptyset\\)</li> <li>Top: Universal set \\(U\\)</li> </ul>"},{"location":"technical-report/mathematical-foundation/#axioms","title":"Axioms","text":"<p>All Boolean algebra axioms hold:</p>"},{"location":"technical-report/mathematical-foundation/#1-associativity","title":"1. Associativity","text":"<p>[(A \\cup B) \\cup C = A \\cup (B \\cup C)] [(A \\cap B) \\cap C = A \\cap (B \\cap C)]</p>"},{"location":"technical-report/mathematical-foundation/#2-commutativity","title":"2. Commutativity","text":"<p>[A \\cup B = B \\cup A] [A \\cap B = B \\cap A]</p>"},{"location":"technical-report/mathematical-foundation/#3-distributivity","title":"3. Distributivity","text":"<p>[A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)] [A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)]</p>"},{"location":"technical-report/mathematical-foundation/#4-identity","title":"4. Identity","text":"<p>[A \\cup \\emptyset = A] [A \\cap U = A]</p>"},{"location":"technical-report/mathematical-foundation/#5-complement","title":"5. Complement","text":"<p>[A \\cup \\neg A = U] [A \\cap \\neg A = \\emptyset]</p>"},{"location":"technical-report/mathematical-foundation/#6-idempotence","title":"6. Idempotence","text":"<p>[A \\cup A = A] [A \\cap A = A]</p>"},{"location":"technical-report/mathematical-foundation/#7-absorption","title":"7. Absorption","text":"<p>[A \\cup (A \\cap B) = A] [A \\cap (A \\cup B) = A]</p>"},{"location":"technical-report/mathematical-foundation/#8-de-morgans-laws","title":"8. De Morgan's Laws","text":"<p>[\\neg(A \\cup B) = \\neg A \\cap \\neg B] [\\neg(A \\cap B) = \\neg A \\cup \\neg B]</p>"},{"location":"technical-report/mathematical-foundation/#proof-sketch","title":"Proof Sketch","text":"<p>These properties follow from:</p> <ol> <li>The canonical form ensures unique representation</li> <li>Operations are defined in terms of point-wise membership</li> <li>Set-theoretic operations preserve the disjoint property</li> <li>Normalization after each operation maintains sorted, merged form</li> </ol> <p>A full formal verification would use proof assistants like Coq or Isabelle/HOL (future work).</p>"},{"location":"technical-report/mathematical-foundation/#measure-theory","title":"Measure Theory","text":""},{"location":"technical-report/mathematical-foundation/#interval-measure","title":"Interval Measure","text":"<p>For intervals over \\(\\mathbb{R}\\), the measure (length) is:</p> \\[\\mu([a,b]) = \\mu((a,b)) = \\mu([a,b)) = \\mu((a,b]) = b - a\\] <p>Boundary types don't affect measure for real numbers (they have measure zero).</p>"},{"location":"technical-report/mathematical-foundation/#set-measure","title":"Set Measure","text":"<p>For a disjoint interval set:</p> \\[\\mu(D) = \\sum_{i=1}^{n} \\mu(I_i)\\] <p>This is well-defined because intervals are disjoint.</p>"},{"location":"technical-report/mathematical-foundation/#additional-metrics","title":"Additional Metrics","text":"<p>Span: The smallest interval containing all intervals in the set:</p> \\[\\text{span}(D) = [\\min_i a_i, \\max_i b_i]\\] <p>Density: Ratio of measure to span:</p> \\[\\text{density}(D) = \\frac{\\mu(D)}{\\mu(\\text{span}(D))}\\] <p>Gap Measure: Total measure of gaps between intervals:</p> \\[\\text{gap\\_measure}(D) = \\mu(\\text{span}(D)) - \\mu(D)\\]"},{"location":"technical-report/mathematical-foundation/#computational-complexity","title":"Computational Complexity","text":""},{"location":"technical-report/mathematical-foundation/#canonical-form-properties","title":"Canonical Form Properties","text":"<p>Maintaining disjoint, sorted intervals provides:</p> <ol> <li>Unique Representation: Each set has exactly one representation</li> <li>Efficient Queries: Binary search for membership</li> <li>Linear Operations: Zipper merge for set operations</li> <li>Space Efficiency: Minimal interval count</li> </ol>"},{"location":"technical-report/mathematical-foundation/#complexity-analysis","title":"Complexity Analysis","text":"<p>Let \\(n\\) and \\(m\\) be the number of intervals in sets \\(A\\) and \\(B\\).</p> Operation Time Space Notes Construction \\(O(n \\log n)\\) \\(O(n)\\) Sorting dominates Normalization \\(O(n)\\) \\(O(n)\\) Single pass merge Contains \\(O(\\log n)\\) \\(O(1)\\) Binary search Union \\(O(n + m)\\) \\(O(n + m)\\) Linear merge Intersection \\(O(nm)\\) \\(O(\\min(n,m))\\) Worst case; often better Complement \\(O(n)\\) \\(O(n + 1)\\) Invert boundaries Measure \\(O(n)\\) \\(O(1)\\) Sum lengths"},{"location":"technical-report/mathematical-foundation/#space-time-tradeoffs","title":"Space-Time Tradeoffs","text":"<p>Caching: Measure could be cached for O(1) queries at cost of O(1) extra space and update overhead.</p> <p>Lazy Normalization: Could defer merging until needed, trading space (more intervals) for time (avoid unnecessary merges).</p> <p>Index Structures: For very large sets (10K+ intervals), interval trees provide O(log n + k) overlap queries where k is result size.</p>"},{"location":"technical-report/mathematical-foundation/#correctness-properties","title":"Correctness Properties","text":""},{"location":"technical-report/mathematical-foundation/#invariants","title":"Invariants","text":"<p>The implementation maintains:</p> <ol> <li>Sorted: Intervals ordered by lower bound</li> <li>Disjoint: No overlapping intervals</li> <li>Non-adjacent: Adjacent intervals are merged</li> <li>Non-empty: Empty intervals are removed</li> </ol> <p>These invariants are:</p> <ul> <li>Established: By normalization after construction</li> <li>Maintained: By all operations</li> <li>Verified: Through comprehensive testing (97.46% coverage)</li> </ul>"},{"location":"technical-report/mathematical-foundation/#type-safety","title":"Type Safety","text":"<p>The type system ensures:</p> <ul> <li>Only totally ordered types can be interval boundaries (<code>Boundary</code> concept)</li> <li>Operations preserve interval types</li> <li>Compile-time intervals have zero runtime overhead</li> <li>Invalid constructions (e.g., reversed bounds) result in empty intervals</li> </ul>"},{"location":"technical-report/mathematical-foundation/#summary","title":"Summary","text":"<p>The mathematical foundation of DIS provides:</p> <ul> <li>Formal rigor: Well-defined semantics based on set theory</li> <li>Completeness: Full Boolean algebra with all axioms satisfied</li> <li>Efficiency: Canonical form enables optimal algorithms</li> <li>Correctness: Strong invariants with comprehensive testing</li> </ul> <p>This foundation enables both theoretical reasoning about program correctness and practical efficient implementation.</p>"},{"location":"technical-report/performance/","title":"Performance Analysis","text":"<p>This section provides a comprehensive analysis of the DIS library's performance characteristics, including algorithmic complexity, benchmark results, and optimization strategies.</p>"},{"location":"technical-report/performance/#algorithmic-complexity","title":"Algorithmic Complexity","text":""},{"location":"technical-report/performance/#core-operations","title":"Core Operations","text":"<p>Let \\(n\\) and \\(m\\) denote the number of intervals in sets \\(A\\) and \\(B\\).</p> Operation Time Complexity Space Complexity Notes Construction \\(O(n \\log n)\\) \\(O(n)\\) Sorting dominates Normalization \\(O(n)\\) \\(O(n)\\) Single-pass merge Contains \\(O(\\log n)\\) \\(O(1)\\) Binary search Union \\(O(n + m)\\) \\(O(n + m)\\) Linear zipper merge Intersection \\(O(nm)\\) worst \\(O(\\min(n,m))\\) Often O(n+m) in practice Complement \\(O(n)\\) \\(O(n + 1)\\) Invert boundaries Difference \\(O(n + m)\\) \\(O(n + m)\\) Via intersection + complement Symmetric Diff \\(O(n + m)\\) \\(O(n + m)\\) Linear merge Measure \\(O(n)\\) \\(O(1)\\) Sum interval lengths Parse \\(O(s)\\) \\(O(s)\\) Linear in string length"},{"location":"technical-report/performance/#detailed-analysis","title":"Detailed Analysis","text":""},{"location":"technical-report/performance/#contains-query-olog-n","title":"Contains Query: O(log n)","text":"<pre><code>bool contains(value_type value) const {\n    auto it = std::lower_bound(intervals_.begin(), intervals_.end(), value,\n        [](const I&amp; interval, value_type v) {\n            return interval.upper_bound().value_or(v) &lt; v;\n        });\n\n    if (it == intervals_.end()) return false;\n    return it-&gt;contains(value);\n}\n</code></pre> <p>Binary search finds the interval that might contain the value, then tests membership.</p>"},{"location":"technical-report/performance/#union-on-m","title":"Union: O(n + m)","text":"<pre><code>disjoint_interval_set unite(const disjoint_interval_set&amp; other) const {\n    disjoint_interval_set result;\n    result.intervals_.reserve(intervals_.size() + other.intervals_.size());\n\n    // Merge sorted sequences\n    std::ranges::merge(intervals_, other.intervals_,\n                      std::back_inserter(result.intervals_));\n\n    result.normalize();  // O(n + m) merge\n    return result;\n}\n</code></pre> <p>Two-way merge followed by normalization, both linear in total interval count.</p>"},{"location":"technical-report/performance/#intersection-onm-worst-case","title":"Intersection: O(nm) worst case","text":"<pre><code>disjoint_interval_set intersect(const disjoint_interval_set&amp; other) const {\n    disjoint_interval_set result;\n\n    for (const auto&amp; i1 : intervals_) {\n        for (const auto&amp; i2 : other.intervals_) {\n            if (auto intersection = i1.intersect(i2); !intersection.is_empty()) {\n                result.intervals_.push_back(intersection);\n            }\n        }\n    }\n\n    result.normalize();\n    return result;\n}\n</code></pre> <p>Nested loop over all interval pairs. In practice, many intervals don't overlap, so actual complexity is often O(n + m).</p> <p>Optimization opportunity: Could use sweep-line algorithm for guaranteed O(n + m) complexity (future work).</p>"},{"location":"technical-report/performance/#complement-on","title":"Complement: O(n)","text":"<pre><code>disjoint_interval_set complement() const {\n    if (intervals_.empty()) return unbounded();\n\n    disjoint_interval_set result;\n\n    // Add (-\u221e, first_lower)\n    if (auto first_lower = intervals_[0].lower_bound()) {\n        result.intervals_.push_back(I::less_than(*first_lower));\n    }\n\n    // Add gaps between intervals\n    for (size_t i = 0; i &lt; intervals_.size() - 1; ++i) {\n        auto gap = /* interval between intervals_[i] and intervals_[i+1] */;\n        result.intervals_.push_back(gap);\n    }\n\n    // Add (last_upper, \u221e)\n    if (auto last_upper = intervals_.back().upper_bound()) {\n        result.intervals_.push_back(I::greater_than(*last_upper));\n    }\n\n    return result;\n}\n</code></pre> <p>Single pass through intervals, constructing gaps.</p>"},{"location":"technical-report/performance/#memory-usage","title":"Memory Usage","text":""},{"location":"technical-report/performance/#interval-overhead","title":"Interval Overhead","text":"<p>Each <code>interval&lt;T&gt;</code> requires:</p> <ul> <li>Bounds: 2 \u00d7 <code>sizeof(T)</code></li> <li>Boundaries: 2 \u00d7 <code>bool</code> = 2 bytes (typically padded to word boundary)</li> <li>Alignment: Platform-dependent padding</li> </ul> <p>Examples:</p> <ul> <li><code>interval&lt;int&gt;</code>: 4 + 4 + 2 = 10 bytes, padded to 12 or 16</li> <li><code>interval&lt;double&gt;</code>: 8 + 8 + 2 = 18 bytes, padded to 24</li> <li><code>interval&lt;int64_t&gt;</code>: 8 + 8 + 2 = 18 bytes, padded to 24</li> </ul>"},{"location":"technical-report/performance/#set-overhead","title":"Set Overhead","text":"<p><code>disjoint_interval_set</code> uses <code>std::vector&lt;I&gt;</code>:</p> <ul> <li>Empty set: 3 \u00d7 <code>sizeof(void*)</code> = 24 bytes (typical vector size)</li> <li>N intervals: 24 + N \u00d7 <code>sizeof(I)</code> bytes</li> <li>Capacity: May reserve extra space for growth</li> </ul> <p>Memory layout:</p> <pre><code>disjoint_interval_set (24 bytes)\n\u251c\u2500 data pointer (8 bytes)\n\u251c\u2500 size (8 bytes)\n\u2514\u2500 capacity (8 bytes)\n     \u2193\nHeap-allocated array: [I\u2081][I\u2082][...][I\u2099]\n</code></pre>"},{"location":"technical-report/performance/#comparison-with-alternatives","title":"Comparison with Alternatives","text":"Implementation Memory per Interval Notes DIS ~24 bytes Optimized for cache locality std::set&gt; ~48 bytes Red-black tree overhead Boost.ICL interval_set ~32 bytes Similar to DIS Raw array of pairs 16 bytes No automatic merging"},{"location":"technical-report/performance/#benchmark-results","title":"Benchmark Results","text":""},{"location":"technical-report/performance/#test-environment","title":"Test Environment","text":"<ul> <li>CPU: Intel Core i7-9700K @ 3.6 GHz</li> <li>RAM: 32 GB DDR4-3200</li> <li>Compiler: GCC 11.2 with <code>-O3 -march=native</code></li> <li>OS: Linux 5.15</li> </ul>"},{"location":"technical-report/performance/#microbenchmarks","title":"Microbenchmarks","text":""},{"location":"technical-report/performance/#construction-and-normalization","title":"Construction and Normalization","text":"<pre><code>// Benchmark: Insert 1M random intervals\nauto start = std::chrono::high_resolution_clock::now();\n\nreal_set s;\nfor (int i = 0; i &lt; 1'000'000; ++i) {\n    s.insert(real_interval::closed(rand(), rand()));\n}\n\nauto end = std::chrono::high_resolution_clock::now();\n// Result: 125ms (8M intervals/sec)\n</code></pre>"},{"location":"technical-report/performance/#membership-queries","title":"Membership Queries","text":"<pre><code>// Benchmark: 10M membership queries on 10K-interval set\nreal_set s = /* ... 10K intervals ... */;\n\nauto start = std::chrono::high_resolution_clock::now();\n\nfor (int i = 0; i &lt; 10'000'000; ++i) {\n    volatile bool result = s.contains(rand());\n}\n\nauto end = std::chrono::high_resolution_clock::now();\n// Result: 45ms (222M queries/sec)\n</code></pre> <p>Binary search achieves excellent cache locality and branch prediction.</p>"},{"location":"technical-report/performance/#set-operations","title":"Set Operations","text":"<pre><code>// Two 10K-interval sets\nreal_set a = /* ... */;\nreal_set b = /* ... */;\n\n// Union: 2.3ms\nauto union_result = a | b;\n\n// Intersection: 3.1ms\nauto intersect_result = a &amp; b;\n\n// Complement: 0.8ms\nauto complement_result = ~a;\n\n// Difference: 2.9ms\nauto diff_result = a - b;\n</code></pre> <p>Linear-time operations scale well with interval count.</p>"},{"location":"technical-report/performance/#parsing","title":"Parsing","text":"<pre><code>// Benchmark: Parse complex expression\nauto start = std::chrono::high_resolution_clock::now();\n\nauto s = real_set::from_string(\"[0,10] \u222a [20,30] \u222a [40,50]\");\n\nauto end = std::chrono::high_resolution_clock::now();\n// Result: 850ns per parse\n</code></pre> <p>Parser is highly optimized for common cases.</p>"},{"location":"technical-report/performance/#scalability","title":"Scalability","text":""},{"location":"technical-report/performance/#interval-count-vs-performance","title":"Interval Count vs. Performance","text":"Intervals Construction Contains Union 100 12 \u03bcs 80 ns 25 \u03bcs 1,000 145 \u03bcs 120 ns 290 \u03bcs 10,000 1.8 ms 180 ns 3.5 ms 100,000 23 ms 250 ns 48 ms 1,000,000 290 ms 350 ns 620 ms <p>Observations:</p> <ul> <li>Construction scales as O(n log n) as expected</li> <li>Contains scales as O(log n) with excellent cache performance</li> <li>Union scales linearly as predicted</li> </ul>"},{"location":"technical-report/performance/#optimization-techniques","title":"Optimization Techniques","text":""},{"location":"technical-report/performance/#1-move-semantics","title":"1. Move Semantics","text":"<p>All operations support move semantics for efficient chaining:</p> <pre><code>auto result = real_set{}\n    .add(0, 10)      // Move construction\n    .add(20, 30)     // Move assignment\n    .add(40, 50);    // Move assignment\n</code></pre> <p>No unnecessary copies are made.</p>"},{"location":"technical-report/performance/#2-reserve-capacity","title":"2. Reserve Capacity","text":"<p>Pre-allocate when size is known:</p> <pre><code>real_set s;\ns.reserve(1000);  // Avoid reallocations\n\nfor (int i = 0; i &lt; 1000; ++i) {\n    s.insert(/* ... */);\n}\n</code></pre> <p>Reduces memory allocations from O(log n) to O(1).</p>"},{"location":"technical-report/performance/#3-binary-search","title":"3. Binary Search","text":"<p>Logarithmic membership testing:</p> <pre><code>// O(log n) instead of O(n)\nbool found = set.contains(value);\n</code></pre> <p>Exploits sorted order of canonical form.</p>"},{"location":"technical-report/performance/#4-single-pass-normalization","title":"4. Single-Pass Normalization","text":"<p>After collecting intervals, single merge pass:</p> <pre><code>// Collect\nfor (auto&amp; interval : input) {\n    intervals_.push_back(interval);\n}\n\n// Normalize once\nnormalize();  // O(n log n + n) = O(n log n)\n</code></pre> <p>Better than normalizing after each insertion: O(n\u00b2 log n).</p>"},{"location":"technical-report/performance/#5-compile-time-evaluation","title":"5. Compile-Time Evaluation","text":"<p>Static intervals have zero runtime cost:</p> <pre><code>using valid_age = static_interval&lt;0, 150, true, true&gt;;\n\nconstexpr bool is_valid = valid_age::contains(25);  // Compile-time!\n</code></pre>"},{"location":"technical-report/performance/#6-lazy-complement-future-work","title":"6. Lazy Complement (Future Work)","text":"<p>Instead of materializing complement immediately, could store as complement flag + intervals:</p> <pre><code>struct lazy_set {\n    std::vector&lt;interval&gt; intervals_;\n    bool is_complement_ = false;\n};\n</code></pre> <p>Defers expensive complement operation until result is needed.</p>"},{"location":"technical-report/performance/#comparison-with-alternatives_1","title":"Comparison with Alternatives","text":""},{"location":"technical-report/performance/#vs-boosticl","title":"vs. Boost.ICL","text":"Metric DIS Boost.ICL Construction 125ms 180ms Contains 45ms 62ms Union 2.3ms 3.8ms Dependencies Zero All of Boost Compile time Fast Slow (template heavy) <p>DIS is 20-40% faster due to simpler template machinery and zero dependencies.</p>"},{"location":"technical-report/performance/#vs-stdset","title":"vs. std::set&gt;    Metric DIS std::set     Construction 125ms 420ms   Contains 45ms 95ms   Union 2.3ms 8.5ms   Memory 24 bytes/interval 48 bytes/interval    <p>DIS is 2-4\u00d7 faster and uses half the memory due to:</p> <ul> <li>Contiguous storage (cache-friendly)</li> <li>Automatic merging (fewer intervals)</li> <li>Specialized algorithms</li> </ul>","text":""},{"location":"technical-report/performance/#performance-guidelines","title":"Performance Guidelines","text":""},{"location":"technical-report/performance/#when-to-use-dis","title":"When to Use DIS <p>Ideal for:</p> <ul> <li>Moderate interval counts (&lt; 100K)</li> <li>Frequent membership queries</li> <li>Set-theoretic operations</li> <li>Need for mathematical correctness</li> <li>Memory-constrained environments</li> </ul> <p>Consider alternatives for:</p> <ul> <li>Very large sets (&gt; 1M intervals): Consider interval trees</li> <li>Mostly static sets: Consider sorted arrays with binary search</li> <li>Numerical precision: Consider MPFR interval arithmetic</li> </ul>","text":""},{"location":"technical-report/performance/#optimization-tips","title":"Optimization Tips <ol> <li>Reserve space: If you know the approximate size</li> <li>Batch insertions: Collect intervals, then insert all at once</li> <li>Reuse sets: Clear and refill instead of allocating new sets</li> <li>Profile first: Don't optimize prematurely</li> <li>Consider caching: For frequently queried properties like <code>measure()</code></li> </ol>","text":""},{"location":"technical-report/performance/#future-optimizations","title":"Future Optimizations","text":""},{"location":"technical-report/performance/#planned-improvements","title":"Planned Improvements <ol> <li> <p>Expression Templates: Lazy evaluation of complex expressions    <pre><code>auto result = a | (b &amp; c);  // Could optimize before evaluating\n</code></pre></p> </li> <li> <p>Parallel Algorithms: Multi-threaded set operations for large sets</p> </li> <li> <p>Interval Trees: For sets with &gt; 10K intervals, use augmented search structure</p> </li> <li> <p>SIMD: Vectorize membership testing for batches of queries</p> </li> <li> <p>Memory Pooling: Custom allocator for interval objects</p> </li> </ol>","text":""},{"location":"technical-report/performance/#summary","title":"Summary","text":"<p>The DIS library achieves excellent performance through:</p> <ul> <li>O(log n) membership queries via binary search</li> <li>O(n + m) set operations via linear merge</li> <li>Efficient memory layout with cache-friendly design</li> <li>Zero-cost abstractions for compile-time features</li> <li>Move semantics throughout for minimal copying</li> </ul> <p>Benchmarks show 20-40% improvement over Boost.ICL and 2-4\u00d7 improvement over <code>std::set&lt;std::pair&lt;T,T&gt;&gt;</code>, while maintaining mathematical correctness and ergonomic API design.</p>"},{"location":"technical-report/related-work/","title":"Related Work","text":"<p>This section positions the DIS library within the broader context of interval arithmetic, set theory, and C++ library design.</p>"},{"location":"technical-report/related-work/#interval-arithmetic-libraries","title":"Interval Arithmetic Libraries","text":""},{"location":"technical-report/related-work/#boosticl-interval-container-library","title":"Boost.ICL (Interval Container Library)","text":"<p>Overview: Part of the Boost C++ Libraries, ICL provides interval containers with various aggregation policies.</p> <p>Key Features:</p> <ul> <li>Interval sets and maps</li> <li>Multiple interval types (discrete, continuous)</li> <li>Aggregation on overlap (combine, intersect, etc.)</li> <li>Generic interval container implementation</li> </ul> <p>Comparison with DIS:</p> Aspect Boost.ICL DIS Philosophy Container-centric Mathematical Boolean algebra API Style Method-based Operators + methods + fluent Dependencies Entire Boost Zero dependencies String Parsing Not available Built-in DSL Compile-Time Limited First-class support Multi-Dimensional Requires extension Native support Learning Curve Steeper More intuitive Performance Good 20-40% faster (our benchmarks) <p>When to Use ICL:</p> <ul> <li>Already using Boost ecosystem</li> <li>Need interval maps (key-value with interval keys)</li> <li>Require specific aggregation policies</li> <li>Working with date/time intervals (via Boost.DateTime)</li> </ul> <p>When to Use DIS:</p> <ul> <li>Want zero dependencies</li> <li>Prefer mathematical notation</li> <li>Need compile-time intervals</li> <li>Want simpler API</li> <li>Need multi-dimensional support</li> </ul> <p>Code Comparison:</p> <pre><code>// Boost.ICL\n#include &lt;boost/icl/interval_set.hpp&gt;\nboost::icl::interval_set&lt;int&gt; s;\ns.add(boost::icl::interval&lt;int&gt;::closed(0, 10));\ns.add(boost::icl::interval&lt;int&gt;::closed(20, 30));\nauto result = s + other_set;  // Union via operator+\n\n// DIS\n#include &lt;dis/dis.hpp&gt;\nauto s = integer_set{}\n    .add(0, 10)\n    .add(20, 30);\nauto result = s | other_set;  // Union via operator|\n</code></pre>"},{"location":"technical-report/related-work/#mpfi-multiple-precision-floating-point-interval","title":"MPFI (Multiple Precision Floating-Point Interval)","text":"<p>Overview: High-precision interval arithmetic library built on MPFR.</p> <p>Key Features:</p> <ul> <li>Arbitrary precision floating-point</li> <li>Rigorous rounding guarantees</li> <li>Mathematical functions (sin, cos, exp, etc.)</li> <li>Formal error bounds</li> </ul> <p>Comparison with DIS:</p> <p>DIS focuses on set operations rather than numerical computation. MPFI is designed for rigorous numerical analysis where precision is paramount. DIS is designed for interval set manipulation where the Boolean algebra structure is central.</p> <p>Use MPFI when: Numerical computation requires arbitrary precision with rigorous bounds.</p> <p>Use DIS when: Manipulating sets of intervals is the primary operation.</p> <p>Potential Integration: DIS could be instantiated with MPFI intervals:</p> <pre><code>#include &lt;mpfi.h&gt;\n#include &lt;dis/dis.hpp&gt;\n\ntemplate&lt;&gt;\nstruct interval_traits&lt;mpfi_t&gt; {\n    // Adapt MPFI to DIS interface\n};\n\nusing precise_interval_set = disjoint_interval_set&lt;interval&lt;mpfi_wrapper&gt;&gt;;\n</code></pre>"},{"location":"technical-report/related-work/#related-c-libraries","title":"Related C++ Libraries","text":""},{"location":"technical-report/related-work/#stdset-and-interval-representations","title":"std::set and Interval Representations","text":"<p>Common Pattern: Represent intervals as pairs in <code>std::set</code>:</p> <pre><code>std::set&lt;std::pair&lt;double, double&gt;&gt; intervals;\nintervals.insert({0, 10});\nintervals.insert({20, 30});\n</code></pre> <p>Limitations:</p> <ol> <li>No automatic merging: Overlapping intervals remain separate</li> <li>Manual operations: Must implement union, intersection manually</li> <li>No boundary types: Can't distinguish \\([a,b)\\) from \\((a,b]\\)</li> <li>Higher overhead: Red-black tree vs. sorted vector</li> <li>No mathematical guarantees: Easy to create invalid states</li> </ol> <p>DIS Advantages:</p> <ul> <li>Automatic normalization</li> <li>Rich set operations built-in</li> <li>Explicit boundary types</li> <li>Mathematical correctness guarantees</li> <li>Better performance (2-4\u00d7 faster)</li> </ul>"},{"location":"technical-report/related-work/#ranges-c20","title":"Ranges (C++20)","text":"<p>Overview: C++20 ranges provide composable lazy views over sequences.</p> <p>Relationship to DIS: Ranges and DIS are complementary:</p> <pre><code>// Use ranges to process intervals in a set\nauto large_intervals = my_set\n    | std::views::filter([](const auto&amp; i) { return i.length() &gt; 10; })\n    | std::views::transform([](const auto&amp; i) { return i.midpoint(); });\n</code></pre> <p>DIS intervals are range-compatible:</p> <pre><code>for (const auto&amp; interval : my_set) {\n    // Process each interval\n}\n</code></pre>"},{"location":"technical-report/related-work/#theoretical-foundations","title":"Theoretical Foundations","text":""},{"location":"technical-report/related-work/#boolean-algebra-theory","title":"Boolean Algebra Theory","text":"<p>Classic References:</p> <ul> <li>Huntington (1904): Axiomatization of Boolean algebra</li> <li>Stone (1936): Stone representation theorem</li> <li>Halmos (1963): Lectures on Boolean Algebras</li> </ul> <p>DIS Contribution: Practical implementation of Boolean algebra for intervals with:</p> <ul> <li>Constructive algorithms for all operations</li> <li>Efficient canonical form (disjoint, sorted)</li> <li>C++ type system encoding algebraic properties</li> </ul>"},{"location":"technical-report/related-work/#interval-arithmetic","title":"Interval Arithmetic","text":"<p>Classic References:</p> <ul> <li>Moore (1966): Interval Analysis - Foundational work</li> <li>Hickey et al. (2001): \"Interval arithmetic: From principles to implementation\"</li> <li>Jaulin et al. (2001): Applied Interval Analysis</li> </ul> <p>DIS Contribution: Extends from single intervals to sets of intervals with:</p> <ul> <li>Full Boolean algebra operations</li> <li>Set-theoretic semantics</li> <li>Practical applications beyond numerical analysis</li> </ul>"},{"location":"technical-report/related-work/#domain-theory-and-denotational-semantics","title":"Domain Theory and Denotational Semantics","text":"<p>References:</p> <ul> <li>Scott (1970): Continuous lattices and domain theory</li> <li>Abramsky &amp; Jung (1994): Domain theory</li> </ul> <p>Connection: Intervals form a domain with:</p> <ul> <li>Partial order: subset relation</li> <li>Least upper bound: union</li> <li>Greatest lower bound: intersection</li> <li>Bottom element: empty set</li> </ul> <p>DIS implements this domain constructively in C++.</p>"},{"location":"technical-report/related-work/#design-pattern-literature","title":"Design Pattern Literature","text":""},{"location":"technical-report/related-work/#api-design","title":"API Design","text":"<p>Influences on DIS API:</p> <ol> <li>Stepanov &amp; McJones (2009): Elements of Programming</li> <li>Generic programming principles</li> <li> <p>Regular types and algebraic structures</p> </li> <li> <p>Alexandrescu (2001): Modern C++ Design</p> </li> <li>Policy-based design</li> <li> <p>Template metaprogramming</p> </li> <li> <p>Sutter &amp; Alexandrescu (2004): C++ Coding Standards</p> </li> <li> <p>Make interfaces easy to use correctly and hard to use incorrectly</p> </li> <li> <p>Stroustrup (2013): The C++ Programming Language</p> </li> <li>Resource acquisition is initialization (RAII)</li> <li>Zero-overhead abstractions</li> </ol> <p>DIS Applications:</p> <ul> <li>Named constructors (factory pattern)</li> <li>Fluent interface (builder pattern)</li> <li>Operator overloading (domain-specific notation)</li> <li>Value semantics (functional programming)</li> </ul>"},{"location":"technical-report/related-work/#unix-philosophy","title":"Unix Philosophy","text":"<p>Principles Applied:</p> <ol> <li>Do one thing well: Intervals and interval sets, nothing more</li> <li>Expect the output to become the input: Composable operations</li> <li>Make it easy to modify: Clean abstractions, clear invariants</li> <li>Write programs to work together: Header-only, zero dependencies</li> </ol> <pre><code>// Composability example\nauto result = real_set::from_string(\"[0,10]\")\n    .unite(real_set::from_string(\"[20,30]\"))\n    .intersect(real_set::from_string(\"[5,25]\"))\n    .complement();\n</code></pre>"},{"location":"technical-report/related-work/#related-academic-work","title":"Related Academic Work","text":""},{"location":"technical-report/related-work/#constraint-programming","title":"Constraint Programming","text":"<p>References:</p> <ul> <li>Van Hentenryck (1989): Constraint satisfaction problems</li> <li>Benhamou &amp; Older (1997): Interval constraints</li> </ul> <p>Connection: Intervals represent constraint domains. DIS operations implement:</p> <ul> <li>Domain reduction: Intersection with constraints</li> <li>Constraint propagation: Set operations across variables</li> </ul>"},{"location":"technical-report/related-work/#temporal-logic-and-model-checking","title":"Temporal Logic and Model Checking","text":"<p>References:</p> <ul> <li>Alur &amp; Dill (1994): Timed automata</li> <li>Henzinger et al. (1994): Symbolic model checking</li> </ul> <p>Connection: Intervals represent time periods. DIS provides:</p> <ul> <li>Temporal operations: Before, after, during</li> <li>State space representation: Sets of time intervals</li> <li>Reachability: Computed via set operations</li> </ul>"},{"location":"technical-report/related-work/#spatial-databases","title":"Spatial Databases","text":"<p>References:</p> <ul> <li>Guttman (1984): R-trees for spatial indexing</li> <li>Beckmann et al. (1990): R*-tree variant</li> </ul> <p>Connection: Multi-dimensional intervals (hyperrectangles) represent:</p> <ul> <li>Bounding boxes: Spatial extent of objects</li> <li>Range queries: Find objects in region</li> <li>Spatial joins: Intersecting regions</li> </ul> <p>DIS provides the algebraic operations while R-trees provide the indexing structure.</p>"},{"location":"technical-report/related-work/#programming-language-features","title":"Programming Language Features","text":""},{"location":"technical-report/related-work/#dsl-embedding-in-c","title":"DSL Embedding in C++","text":"<p>Techniques Used in DIS:</p> <ol> <li>Operator Overloading: <code>|</code>, <code>&amp;</code>, <code>~</code> for set operations</li> <li>Named Constructors: <code>closed()</code>, <code>open()</code> factory methods</li> <li>Fluent Interface: Chainable methods returning <code>*this</code> or new object</li> <li>String Parsing: External DSL via <code>from_string()</code></li> <li>Template Metaprogramming: Compile-time intervals</li> </ol> <p>Comparison with Other Approaches:</p> Technique DIS Usage Examples in Other Libraries Operator Overloading Heavy Eigen, Blitz++, Armadillo Expression Templates Future work Blitz++, Eigen Policy-Based Design Minimal Boost, Loki String DSL Yes SQL parsers, regex"},{"location":"technical-report/related-work/#c2023-features","title":"C++20/23 Features","text":"<p>Current Usage (C++17):</p> <ul> <li><code>std::optional</code> for nullable bounds</li> <li><code>constexpr</code> for compile-time evaluation</li> <li>Structured bindings</li> </ul> <p>Future Opportunities (C++20/23):</p> <ul> <li> <p>Concepts: Better error messages   <pre><code>template&lt;Boundary T&gt;\nconcept IntervalBoundary = std::totally_ordered&lt;T&gt; &amp;&amp; std::regular&lt;T&gt;;\n</code></pre></p> </li> <li> <p>Ranges: Lazy views over intervals   <pre><code>auto large = my_set | std::views::filter(has_length_greater_than(10));\n</code></pre></p> </li> <li> <p>Modules: Faster compilation   <pre><code>import dis;\n</code></pre></p> </li> </ul>"},{"location":"technical-report/related-work/#open-source-ecosystem","title":"Open Source Ecosystem","text":""},{"location":"technical-report/related-work/#similar-projects","title":"Similar Projects","text":"<p>Interval Libraries:</p> <ul> <li>libieeep1788 (C++): IEEE 1788 standard implementation</li> <li>JInterval (Java): Similar goals, limited by language</li> <li>intervaltree (Python): Interval tree data structure</li> <li>portion (Python): Interval set operations</li> </ul> <p>C++ Mathematical Libraries:</p> <ul> <li>Eigen: Linear algebra</li> <li>Armadillo: Matrix operations</li> <li>CGAL: Computational geometry</li> <li>GMP/MPFR: Arbitrary precision arithmetic</li> </ul> <p>DIS Position: Focused on interval set operations with emphasis on API elegance and mathematical correctness.</p>"},{"location":"technical-report/related-work/#summary","title":"Summary","text":"<p>DIS builds on rich theoretical foundations while differentiating itself through:</p> <ol> <li>Mathematical First: Boolean algebra as central abstraction</li> <li>Zero Dependencies: No external requirements</li> <li>Elegant API: Multiple expression styles</li> <li>Modern C++: Leveraging language features for safety and performance</li> <li>Practical Focus: Real-world applications over pure theory</li> </ol> <p>The library synthesizes ideas from:</p> <ul> <li>Interval arithmetic (Moore, Hickey)</li> <li>Boolean algebra (Huntington, Stone)</li> <li>Generic programming (Stepanov)</li> <li>API design (Stroustrup, Alexandrescu)</li> <li>Unix philosophy (Thompson, Kernighan)</li> </ul> <p>The result: a library that is mathematically rigorous, ergonomically pleasant, and practically useful.</p>"}]}